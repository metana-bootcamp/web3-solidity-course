<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Math for Smart Contracts — Curves, Fixed-Point &amp; PRBMath Internals</title>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@5.1.0/dist/reveal.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@5.1.0/dist/theme/black.css" id="theme">
  <script src="https://www.desmos.com/api/v1.8/calculator.js?apiKey=dcb31709b452b1cf9dc26972add0fda6"></script>
  <style>
    .reveal section h1, .reveal section h2, .reveal section h3 { text-transform: none; }
    .reveal section h2 { margin-bottom: 0.2em; }
    .reveal section p { margin-top: 0.15em; margin-bottom: 0.15em; }
    .reveal ul { font-size: 0.82em; margin-top: 0.15em; margin-bottom: 0.15em; }
    .reveal ul li { margin-bottom: 0.1em; }
    .reveal pre { margin: 0.25em auto; }
    .reveal pre code { font-size: 0.55em; line-height: 1.3; max-height: 400px; overflow-y: auto; }
    .subtle { color: #bbb; font-size: 0.68em; margin-top: 0.2em; margin-bottom: 0; }
    .two-col { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; align-items: start; }
    .three-col { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; align-items: start; }
    .badge { display: inline-block; padding: 3px 7px; border-radius: 6px; background: rgba(255,255,255,0.1); font-size: 0.72em; }
    .calc { width: 100%; height: 250px; border: 1px solid rgba(255,255,255,0.12); border-radius: 10px; overflow: hidden; background: #0b0f1c; }
    .callout, .callout-blue, .callout-green, .callout-red { padding: 6px 10px; border-radius: 6px; font-size: 0.72em; margin: 4px 0; }
    .callout { background: rgba(255,255,255,0.06); border-left: 3px solid #f5a623; }
    .callout-blue { background: rgba(45,156,219,0.08); border-left: 3px solid #2d9cdb; }
    .callout-green { background: rgba(39,174,96,0.08); border-left: 3px solid #27ae60; }
    .callout-red { background: rgba(231,76,60,0.08); border-left: 3px solid #e74c3c; }
    .formula { font-family: monospace; font-size: 1.05em; color: #f5a623; }
    .formula-lg { font-family: monospace; font-size: 1.25em; color: #f5a623; }
    .truth-table { width: 100%; border-collapse: collapse; font-size: 0.7em; margin: 0.3em 0; }
    .truth-table th { background: rgba(255,255,255,0.08); padding: 4px 8px; text-align: center; border-bottom: 2px solid rgba(255,255,255,0.2); }
    .truth-table td { padding: 3px 8px; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.06); }
    .truth-table tr:hover td { background: rgba(255,255,255,0.04); }
    .step-num { display: inline-block; width: 24px; height: 24px; line-height: 24px; text-align: center; border-radius: 50%; background: #f5a623; color: #000; font-weight: bold; font-size: 0.75em; margin-right: 5px; }
    .highlight-line { background: rgba(245,166,35,0.15) !important; }
    .gas-tag { display: inline-block; padding: 2px 6px; border-radius: 4px; background: rgba(39,174,96,0.15); color: #27ae60; font-size: 0.65em; font-weight: bold; }
    .asm-keyword { color: #e74c3c; }
    .fn-name { color: #9b59b6; font-weight: bold; }
    @media (max-width: 900px) {
      .reveal ul { font-size: 0.82em; }
      .reveal pre code { font-size: 0.5em; }
      .calc { height: 200px; }
      .two-col, .three-col { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <!-- ══════════════════════════════════════════════
           PART 0 — INTRO
           ══════════════════════════════════════════════ -->
      <section>
        <h1>Math for Smart Contracts</h1>
        <h3>Curves, Fixed-Point &amp; PRBMath</h3>
        <p><span class="badge">Pre-requisite</span> <span class="badge">Solidity</span> <span class="badge">Math</span></p>
        <p class="subtle">From middle-school math to reading PRBMath source code</p>
        <aside class="notes">This workshop covers the math foundations that the bonding curves workshop assumes you know. We'll start from middle-school level math — what is a function, what does a graph mean — and build up to fixed-point arithmetic and PRBMath in Solidity. No calculus required. By the end you'll be able to read any PRBMath contract.</aside>
      </section>

      <section>
        <h2>What You Need to Know</h2>
        <ul>
          <li>&check; Basic Solidity: <code>uint256</code>, functions, <code>msg.value</code></li>
          <li>&check; What a smart contract is and how to deploy one</li>
          <li>&cross; No calculus needed</li>
          <li>&cross; No prior math library experience needed</li>
        </ul>
        <div class="callout">
          By the end: you'll understand <strong>curves as functions</strong>, <strong>why floats don't exist in Solidity</strong>, how to use <strong>PRBMath</strong>, and how it works <strong>under the hood</strong>.
        </div>
        <aside class="notes">Let's set expectations. If you can write a simple Solidity contract with a state variable and a function, you're ready. We will NOT need calculus, derivatives, or integrals. We'll build intuition for those concepts visually using graphs.</aside>
      </section>

      <!-- ══════════════════════════════════════════════
           PART 1 — FUNCTIONS: THE BUILDING BLOCK
           ══════════════════════════════════════════════ -->
      <section>
        <h2 style="color:#2d9cdb;">Part 1: What Is a Function?</h2>
        <p>A function is a machine: <strong>input &rarr; rule &rarr; output</strong></p>
        <div class="two-col">
          <div>
            <p class="formula-lg">f(x) = 2x + 3</p>
            <table class="truth-table">
              <tr><th>Input (x)</th><th>Output f(x)</th></tr>
              <tr><td>0</td><td>3</td></tr>
              <tr><td>1</td><td>5</td></tr>
              <tr><td>5</td><td>13</td></tr>
              <tr><td>10</td><td>23</td></tr>
            </table>
          </div>
          <div>
            <p class="subtle" style="margin-top:0;">Same thing in Solidity:</p>
            <pre><code class="hljs">function f(uint256 x) pure returns (uint256) {
    return 2 * x + 3;
}</code></pre>
            <div class="callout">
              Every Solidity <code>view</code>/<code>pure</code> function that takes a number and returns a number <em>is</em> a math function.
            </div>
          </div>
        </div>
        <aside class="notes">This is the most important slide if you're coming from a non-math background. A function is just a rule: you put a number in, you get a number out. f(x) = 2x + 3 means "double the input and add 3". That table on the left IS the function for those specific inputs. The Solidity code on the right does the exact same thing. When we say "bonding curve function" later, it's literally this: a Solidity function where the input is supply and the output is price.</aside>
      </section>

      <!-- ============ GRAPHING A FUNCTION ============ -->
      <section>
        <h2>Graphing a Function</h2>
        <p>A graph plots every (input, output) pair as a dot. Connect the dots &rarr; a <strong>line</strong> or <strong>curve</strong>.</p>
        <div id="calc-intro-line" class="calc"></div>
        <p class="subtle" style="margin-top:0.3em;"><strong>X-axis</strong> = input &nbsp;|&nbsp; <strong>Y-axis</strong> = output &nbsp;|&nbsp; Drag <strong>m</strong> to tilt, <strong>b</strong> to shift &nbsp;|&nbsp; f(x) = m&middot;x + b &rarr; in bonding curves: x = supply, y = price</p>
        <aside class="notes">This is a live Desmos graph. The blue line represents f(x) = mx + b for every value of x at once. The x-axis is horizontal (our input), the y-axis is vertical (our output). If you pick any point on the line and look down to x, that's the input, look left to y, that's the output. Drag the m slider — it's the slope, how steep the line is. Drag b — it's where the line crosses the y-axis. In DeFi, x will be "how many tokens exist" and y will be "what's the current price". That's it — that's a bonding curve.</aside>
      </section>

      <!-- ============ SLOPE ============ -->
      <section>
        <h2>Slope: How Fast Does It Rise?</h2>
        <div class="two-col">
          <div>
            <p class="formula">slope = &Delta;y / &Delta;x</p>
            <ul>
              <li><strong>m = 2</strong> &rarr; steep, output doubles per unit</li>
              <li><strong>m = 0.1</strong> &rarr; gentle, barely changes</li>
              <li><strong>m = 0</strong> &rarr; flat line (fixed price!)</li>
            </ul>
            <div class="callout">
              In DeFi: slope = how much <strong>price increases per token</strong> minted. Try m&nbsp;=&nbsp;0 vs m&nbsp;=&nbsp;1.
            </div>
          </div>
          <div>
            <div id="calc-slope" class="calc"></div>
          </div>
        </div>
        <aside class="notes">Slope is the single most important concept for bonding curves. Rise over run: for every 1 unit you move right on x, how much does y go up? If m=0, the price never changes — that's a fixed-price sale. If m=0.5, every new token costs 0.5 more than the last. If m=2, it's aggressive — prices double per token. The whole point of bonding curves is choosing the right slope (or curve shape) for your economics.</aside>
      </section>

      <!-- ============ LINEAR vs CURVED ============ -->
      <section>
        <h2>Straight Lines vs. Curves</h2>
        <p>A <strong>line</strong> has constant slope. A <strong>curve</strong> has changing slope.</p>
        <div id="calc-line-vs-curve" class="calc"></div>
        <p class="subtle" style="margin-top:0.3em;"><span style="color:#2d9cdb;">&mdash;</span> Blue (linear): same rate &nbsp;|&nbsp; <span style="color:#e97b2e;">&mdash;</span> Orange (expo): accelerates &nbsp;|&nbsp; <span style="color:#27ae60;">&mdash;</span> Green (log): slows down &nbsp;|&nbsp; Each shape = a different economic personality.</p>
        <aside class="notes">Here's the key insight: with a straight line, every new token adds the same price increase. With exponential, early tokens are cheap but later ones get progressively more expensive — the slope itself increases. With logarithmic, the curve rises fast early then flattens — later tokens barely increase in price. You're choosing the economic personality of your token by choosing the shape.</aside>
      </section>

      <!-- ══════════════════════════════════════════════
           PART 2 — MEET THE CURVES
           ══════════════════════════════════════════════ -->
      <section>
        <h2 style="color:#e97b2e;">Part 2: The Five Curves You'll See in DeFi</h2>
        <div class="three-col">
          <div>
            <h3>Linear</h3>
            <p class="formula">y = mx + b</p>
            <p class="subtle">Constant growth</p>
          </div>
          <div>
            <h3>Quadratic</h3>
            <p class="formula">y = ax&sup2;</p>
            <p class="subtle">Accelerating growth</p>
          </div>
          <div>
            <h3>Square Root</h3>
            <p class="formula">y = &radic;x</p>
            <p class="subtle">Decelerating growth</p>
          </div>
        </div>
        <div class="two-col" style="margin-top: 12px;">
          <div>
            <h3>Exponential</h3>
            <p class="formula">y = e<sup>x</sup></p>
            <p class="subtle">Explosive growth</p>
          </div>
          <div>
            <h3>Logarithmic</h3>
            <p class="formula">y = ln(x)</p>
            <p class="subtle">Diminishing growth</p>
          </div>
        </div>
        <aside class="notes">These five shapes are the building blocks. Every bonding curve you'll encounter in DeFi is one of these, or a combination. Let's go through each one with a graph, a table of values, and what it means economically.</aside>
      </section>

      <!-- ============ LINEAR DEEP DIVE ============ -->
      <section>
        <h2>Linear: y = mx + b</h2>
        <div class="two-col">
          <div>
            <p><strong>The idea:</strong> output grows at a constant rate.</p>
            <table class="truth-table">
              <tr><th>x</th><th>y (m=0.5, b=1)</th><th>&Delta;y</th></tr>
              <tr><td>0</td><td>1.0</td><td>&mdash;</td></tr>
              <tr><td>2</td><td>2.0</td><td>+1.0</td></tr>
              <tr><td>4</td><td>3.0</td><td>+1.0</td></tr>
              <tr><td>6</td><td>4.0</td><td>+1.0</td></tr>
              <tr><td>8</td><td>5.0</td><td>+1.0</td></tr>
            </table>
            <div class="callout">
              &Delta;y is always the same &rarr; <strong>straight line</strong>.
            </div>
          </div>
          <div>
            <pre><code class="hljs">// Solidity: linear pricing
function price(uint256 supply)
    pure returns (uint256)
{
    // m = 0.5 (as 5e17 in fixed-point)
    // b = 1   (as 1e18 in fixed-point)
    return supply * 5e17 / 1e18 + 1;
    // simplified: supply / 2 + 1
}</code></pre>
            <p class="subtle"><strong>DeFi use:</strong> community tokens, DAOs. Fair and predictable &mdash; every token adds the same price bump.</p>
          </div>
        </div>
        <aside class="notes">Linear is the simplest. The delta column shows that y always increases by the same amount (1.0 here) for every 2 units of x. That's what makes it a line. In Solidity, this is literally supply-times-slope-plus-base. When we say "bonding curve", a linear one is the easiest to build and audit.</aside>
      </section>

      <!-- ============ QUADRATIC DEEP DIVE ============ -->
      <section>
        <h2>Quadratic: y = ax&sup2;</h2>
        <div class="two-col">
          <div>
            <p><strong>The idea:</strong> the further right, the faster it grows.</p>
            <table class="truth-table">
              <tr><th>x</th><th>y (a=1)</th><th>&Delta;y</th></tr>
              <tr><td>1</td><td>1</td><td>&mdash;</td></tr>
              <tr><td>2</td><td>4</td><td>+3</td></tr>
              <tr><td>3</td><td>9</td><td>+5</td></tr>
              <tr><td>5</td><td>25</td><td>+9</td></tr>
            </table>
            <div class="callout">
              &Delta;y <em>increases</em> each step &rarr; <strong>curved upward</strong>.
            </div>
          </div>
          <div>
            <div id="calc-quadratic" class="calc"></div>
            <p class="subtle"><strong>DeFi use:</strong> Friend.tech (P = S&sup2;/16000), pump.fun. Rewards early buyers aggressively.</p>
          </div>
        </div>
        <aside class="notes">Look at the delta column: 1, 3, 5, 7, 9 — the increases themselves are increasing. That's what makes the graph curve upward. At x=1 you pay 1, at x=5 you pay 25 — that's 25x more for being late. Friend.tech uses exactly this: S squared over 16000. The first key share is basically free, the 100th costs over 0.6 ETH. This is the "FOMO curve".</aside>
      </section>

      <!-- ============ SQUARE ROOT DEEP DIVE ============ -->
      <section>
        <h2>Square Root: y = &radic;x</h2>
        <div class="two-col">
          <div>
            <p><strong>The idea:</strong> fast early rise, then flattens.</p>
            <table class="truth-table">
              <tr><th>x</th><th>y = &radic;x</th><th>&Delta;y</th></tr>
              <tr><td>1</td><td>1.0</td><td>&mdash;</td></tr>
              <tr><td>4</td><td>2.0</td><td>+1.0</td></tr>
              <tr><td>16</td><td>4.0</td><td>+1.0</td></tr>
              <tr><td>100</td><td>10.0</td><td>&mdash;</td></tr>
            </table>
            <div class="callout">
              To double the output you must <strong>quadruple</strong> the input.
            </div>
          </div>
          <div>
            <div id="calc-sqrt" class="calc"></div>
            <p class="subtle"><strong>DeFi use:</strong> Bancor continuous tokens (CW = 0.5). Rewards early growth but doesn't punish latecomers.</p>
          </div>
        </div>
        <aside class="notes">Square root is the opposite personality of quadratic. It rises fast at the beginning — the first 4 tokens produce a big price jump — but then flattens. To go from price 5 to price 10, you need to go from supply 25 to supply 100. That's a lot of tokens for modest price growth. This is the "fair growth" curve: early supporters get rewarded, but it's not punishing to join later.</aside>
      </section>

      <!-- ============ EXPONENTIAL DEEP DIVE ============ -->
      <section>
        <h2>Exponential: y = e<sup>x</sup></h2>
        <div class="two-col">
          <div>
            <p><strong>The idea:</strong> output <em>multiplies</em> rather than adds.</p>
            <table class="truth-table">
              <tr><th>x</th><th>y = e<sup>x</sup></th><th>Ratio</th></tr>
              <tr><td>0</td><td>1.0</td><td>&mdash;</td></tr>
              <tr><td>1</td><td>2.7</td><td>&times;2.7</td></tr>
              <tr><td>3</td><td>20.1</td><td>&times;2.7</td></tr>
              <tr><td>5</td><td>148.4</td><td>&times;2.7</td></tr>
            </table>
            <div class="callout-red">
              Each step <strong>multiplies by 2.7</strong>. By x=5, it's 148&times; the start!
            </div>
          </div>
          <div>
            <div id="calc-expo" class="calc"></div>
            <p class="subtle"><strong>What is <em>e</em>?</strong> ≈ 2.71828 — a special constant. Like &pi;, it shows up everywhere in growth/decay.</p>
          </div>
        </div>
        <aside class="notes">Exponential is the scariest curve. Instead of adding a fixed amount each step, you MULTIPLY by a fixed ratio each step. That ratio is e ≈ 2.718. At x=5 you're at 148 — that's 148 times the starting value in just 5 steps. This is compound growth, the same math as compound interest. In DeFi this means the 50th token might cost 1000x what the first token cost. Extremely aggressive. Only use this if you really want to reward the absolute earliest buyers.</aside>
      </section>

      <!-- ============ WHAT IS e? ============ -->
      <section>
        <h2>Sidebar: What Is <em>e</em>?</h2>
        <p>You know &pi; ≈ 3.14 (circles). Meet <strong>e ≈ 2.718</strong> (growth).</p>
        <ul>
          <li>Imagine $1 in a bank at 100% annual interest</li>
          <li>Compounded <strong>once</strong>: $1 &times; 2 = $2.00</li>
          <li>Compounded <strong>twice</strong>: $1 &times; 1.5&sup2; = $2.25</li>
          <li>Compounded <strong>daily</strong>: $1 &times; (1 + 1/365)<sup>365</sup> = $2.714...</li>
          <li>Compounded <strong>infinitely</strong>: $1 &times; e = <strong>$2.71828...</strong></li>
        </ul>
        <div class="callout-blue">
          <strong>e</strong> = the limit of (1 + 1/n)<sup>n</sup> as n &rarr; &infin;.<br>
          It's the base rate of continuous growth. That's why e<sup>kx</sup> means "grow continuously at rate k".
        </div>
        <aside class="notes">If you've always wondered what e is: it comes from compound interest. If you compound 100% interest more and more frequently, the answer converges to 2.71828 — that's e. It's the natural base for continuous growth. When you see e^(k*x) in a bonding curve, it means "grow continuously at rate k per unit of supply". k controls speed, e is just the mathematical engine that makes continuous compounding work.</aside>
      </section>

      <!-- ============ LOGARITHM DEEP DIVE ============ -->
      <section>
        <h2>Logarithm: y = ln(x)</h2>
        <div class="two-col">
          <div>
            <p><strong>The idea:</strong> inverse of expo. "What exponent gives me x?"</p>
            <table class="truth-table">
              <tr><th>x</th><th>y = ln(x)</th><th>&Delta;y</th></tr>
              <tr><td>1</td><td>0.00</td><td>&mdash;</td></tr>
              <tr><td>10</td><td>2.30</td><td>+2.30</td></tr>
              <tr><td>100</td><td>4.61</td><td>+2.31</td></tr>
            </table>
            <div class="callout">
              1&rarr;10 gains 2.3. 10&rarr;100 gains just 2.3 more. Logarithmic = diminishing returns.
            </div>
          </div>
          <div>
            <div id="calc-log-intro" class="calc"></div>
            <p class="subtle"><strong>DeFi use:</strong> utility tokens. Fast early price growth, then stable &mdash; latecomers aren't punished.</p>
          </div>
        </div>
        <aside class="notes">Logarithm is the mirror image of exponential. It asks: "e to what power gives me x?" If e^2.3 = 10, then ln(10) = 2.3. The practical meaning: ln grows fast at first, then barely moves. Going from 1 to 100 gives you ln = 4.6. Going from 100 to 10,000 would only give you another 4.6. This makes it perfect for utility tokens: early momentum pushes the price up, but it stabilizes for late adopters. Nobody gets punished for joining later.</aside>
      </section>

      <!-- ============ CURVE COMPARISON ============ -->
      <section>
        <h2>All Five Together</h2>
        <div id="calc-all-five" class="calc" style="height: 260px;"></div>
        <ul>
          <li><span style="color:#2d9cdb;">&mdash;</span> Linear &nbsp;|&nbsp; <span style="color:#e74c3c;">&mdash;</span> Quadratic &nbsp;|&nbsp; <span style="color:#27ae60;">&mdash;</span> Square Root &nbsp;|&nbsp; <span style="color:#e97b2e;">&mdash;</span> Exponential &nbsp;|&nbsp; <span style="color:#9b59b6;">&mdash;</span> Logarithmic</li>
        </ul>
        <div class="callout">
          Same input range, wildly different outputs. <strong>Choosing a curve = choosing economics.</strong>
        </div>
        <aside class="notes">Now you can see all five on one graph. Same x-axis range, but look how different they are at x=10. Exponential is already off the chart. Quadratic is rising fast. Linear is moderate. Square root and log are the gentlest. When a DeFi project picks a curve, they're literally picking one of these shapes to control how price behaves as supply grows. It's pure math with direct economic consequences.</aside>
      </section>

      <!-- ══════════════════════════════════════════════
           PART 3 — AREA UNDER A CURVE (INTEGRALS, NO CALCULUS)
           ══════════════════════════════════════════════ -->
      <section>
        <h2 style="color:#27ae60;">Part 3: Area Under a Curve</h2>
        <p>When you buy multiple tokens, each one costs a different price. How do you find the total cost?</p>
        <div class="callout">
          <strong>Total cost = area under the curve</strong> between your start and end supply.
        </div>
        <div id="calc-area" class="calc"></div>
        <p class="subtle">Shaded area = total ETH to buy tokens from supply 2 to 8.</p>
        <aside class="notes">This is where people get scared because someone says "integral". Forget that word for now. Think of it as area. If the x-axis is supply and the y-axis is price, then the total cost of buying tokens from supply 2 to supply 8 is the shaded area under the curve between those two points. Each thin vertical strip is one token at its specific price. Add them all up = total cost. That's it.</aside>
      </section>

      <!-- ============ AREA — COUNTING RECTANGLES ============ -->
      <section>
        <h2>Counting Rectangles (The Loop Way)</h2>
        <p>Curve: <span class="formula">P(s) = 0.5s + 1</span> &nbsp;|&nbsp; Buy tokens #3 &ndash; #7 (5 tokens)</p>
        <div class="two-col">
          <div>
            <table class="truth-table">
              <tr><th>Token</th><th>s</th><th>Price</th></tr>
              <tr><td>3</td><td>2</td><td><strong>2.0</strong></td></tr>
              <tr><td>4</td><td>3</td><td><strong>2.5</strong></td></tr>
              <tr><td>5</td><td>4</td><td><strong>3.0</strong></td></tr>
              <tr><td>6</td><td>5</td><td><strong>3.5</strong></td></tr>
              <tr><td>7</td><td>6</td><td><strong>4.0</strong></td></tr>
            </table>
          </div>
          <div>
            <p class="formula">Total = 2+2.5+3+3.5+4 = <span style="color:#f5a623;">15.0</span></p>
            <div class="callout">
              Solidity: <code>for (i=0; i&lt;5; i++) cost += price(s+i);</code><br>
              Works, but <strong>O(n) gas</strong> &mdash; expensive for large buys.
            </div>
          </div>
        </div>
        <aside class="notes">Here's the simple way: just compute the price at each supply level and add them up. Token 3 is at supply 2, so price is 2.0. Token 4 is at supply 3, price is 2.5. And so on. Total is 15 ETH. In Solidity this is literally a for loop. Problem? If someone buys 1000 tokens, that's 1000 iterations. Each costs gas. At some point it'll hit the block gas limit and fail.</aside>
      </section>

      <!-- ============ AREA — THE SHORTCUT ============ -->
      <section>
        <h2>The Shortcut: One Formula</h2>
        <p>Linear curve &rarr; area = <strong>trapezoid</strong>: <span class="formula">Area = (top + bottom) &times; width / 2</span></p>
        <div class="two-col">
          <div>
            <p class="subtle" style="margin:0;">Bottom = P(2) = 2.0 &nbsp;|&nbsp; Top = P(6) = 4.0 &nbsp;|&nbsp; Width = 5</p>
            <p class="formula">= (2.0 + 4.0) &times; 5 / 2 = <span style="color:#f5a623;">15.0</span> &check;</p>
          </div>
          <div>
            <div class="callout-green">
              <strong>One multiplication replaces the entire loop.</strong><br>
              O(1) gas instead of O(n). Works for any amount!
            </div>
          </div>
        </div>
        <div class="callout">
          Every curve has its own shortcut (the "integral"). Linear: trapezoid. Exponential: (a/k)&middot;(e<sup>kS2</sup>&minus;e<sup>kS1</sup>). You don't derive them &mdash; just plug in.
        </div>
        <aside class="notes">For a straight line, the area between two x-values is a trapezoid. You just need the height at both ends and the width. (2 + 4) times 5 divided by 2 = 15. Same answer as the loop, but ONE computation instead of five. In Solidity: one formula, constant gas, works even for a million tokens. Each curve shape has its own shortcut. For linear it's the trapezoid formula. For exponential it involves e^x. For log it involves x*ln(x). You don't need to derive these — they're in textbooks and in PRBMath docs. You just need to understand WHY we use them: to avoid the gas-expensive loop.</aside>
      </section>

      <!-- ══════════════════════════════════════════════
           PART 4 — THE SOLIDITY PROBLEM: NO FLOATS
           ══════════════════════════════════════════════ -->
      <section>
        <h2 style="color:#e74c3c;">Part 4: Solidity Can't Do Decimals</h2>
        <p>Quick: what's the result of these Solidity operations?</p>
        <pre><code class="hljs">uint256 a = 7 / 2;    // = ?
uint256 b = 1 / 3;    // = ?
uint256 c = 5 / 10;   // = ?</code></pre>
        <div class="callout-red" style="margin-top: 10px;">
          <strong>a = 3, b = 0, c = 0</strong> &mdash; Solidity throws away the decimal part!
        </div>
        <ul>
          <li>7/2 should be 3.5 &rarr; Solidity gives you <strong>3</strong> (truncates toward zero)</li>
          <li>1/3 should be 0.333... &rarr; Solidity gives you <strong>0</strong></li>
          <li>No <code>float</code>, no <code>double</code>, no <code>decimal</code> type exists in Solidity</li>
        </ul>
        <aside class="notes">This is the reality check. If you try to divide 7 by 2 in Solidity, you get 3 — not 3.5. The .5 is gone forever. 1 divided by 3 is 0. Not 0.33, just 0. There is no float type, no double, no decimal. Only integers. Now think about our curves: e^0.08 = 1.0833. How do we compute that? We need a trick.</aside>
      </section>

      <!-- ============ THE TRICK ============ -->
      <section>
        <h2>The Trick: Pretend Integers Are Decimals</h2>
        <p>What if we agree: <strong>"1e18 means 1.0"</strong>?</p>
        <table class="truth-table" style="max-width: 600px; margin: 0 auto;">
          <tr><th>Real Number</th><th>Fixed-Point (×10<sup>18</sup>)</th><th>Solidity Literal</th></tr>
          <tr><td>1.0</td><td>1,000,000,000,000,000,000</td><td><code>1e18</code></td></tr>
          <tr><td>0.5</td><td>500,000,000,000,000,000</td><td><code>5e17</code></td></tr>
          <tr><td>0.08</td><td>80,000,000,000,000,000</td><td><code>8e16</code></td></tr>
          <tr><td>2.5</td><td>2,500,000,000,000,000,000</td><td><code>25e17</code></td></tr>
          <tr><td>3.14159</td><td>3,141,590,000,000,000,000</td><td><code>3141590000000000000</code></td></tr>
        </table>
        <div class="callout">
          This is called <strong>fixed-point arithmetic</strong>. We multiply every number by 10<sup>18</sup> before storing it. The 18 zeros are the "decimal places".
        </div>
        <aside class="notes">Here's the trick. We agree on a convention: every number is stored as itself times 10 to the 18th. So 1.0 is stored as 1 followed by 18 zeros. 0.5 is 5 followed by 17 zeros. Now our integers CAN represent decimals — we just have to remember to account for the scaling. This is called fixed-point arithmetic because the "decimal point" is always at a fixed position — 18 digits from the right. ERC-20 tokens already do this! When you have 1 USDC, the contract stores 1e6. Same idea, just with 18 decimals instead of 6.</aside>
      </section>

      <!-- ============ FIXED-POINT ARITHMETIC ============ -->
      <section>
        <h2>Fixed-Point Arithmetic: The Rules</h2>
        <div class="two-col">
          <div>
            <h3>Addition &amp; Subtraction</h3>
            <p>Just add/subtract normally:</p>
            <pre><code class="hljs">// 1.5 + 0.3 = 1.8
uint256 a = 15e17; // 1.5
uint256 b = 3e17;  // 0.3
uint256 c = a + b; // 18e17 = 1.8 ✓</code></pre>
            <div class="callout-green">
              Addition &amp; subtraction: <strong>no adjustment needed</strong>.
            </div>
          </div>
          <div>
            <h3>Multiplication</h3>
            <p>Divide by 1e18 after multiplying:</p>
            <pre><code class="hljs">// 1.5 × 0.3 = 0.45
uint256 a = 15e17; // 1.5
uint256 b = 3e17;  // 0.3
uint256 c = a * b / 1e18;
// = 45e34 / 1e18 = 45e16 = 0.45 ✓</code></pre>
            <div class="callout-red">
              Multiplication: <strong>must divide by 1e18</strong> to fix the double scaling.
            </div>
          </div>
        </div>
        <aside class="notes">Here's where it gets practical. Addition is easy: 1.5e18 + 0.3e18 = 1.8e18. The scales just add up normally. Multiplication is tricky: 1.5e18 times 0.3e18 = 0.45e36. That's scaled by 10^36, not 10^18! So we divide the result by 1e18 to get back to the correct scale: 0.45e18. This is the #1 gotcha in fixed-point math. If you forget the /1e18 after a multiply, your numbers will be 10^18 too large. Division is the reverse — multiply by 1e18 first, then divide.</aside>
      </section>

      <!-- ============ FIXED-POINT DIVISION ============ -->
      <section>
        <h2>Fixed-Point: Division Trap</h2>
        <pre><code class="hljs">// WRONG: 3.0 / 2.0 = ???
uint256 a = 3e18;  // 3.0
uint256 b = 2e18;  // 2.0
uint256 wrong = a / b;        // = 1  (lost all decimals!)

// RIGHT: multiply FIRST, then divide
uint256 right = a * 1e18 / b; // = 3e36 / 2e18 = 15e17 = 1.5 ✓</code></pre>
        <div class="callout">
          <strong>Rule:</strong> for fixed-point division, multiply the numerator by 1e18 <em>before</em> dividing.
        </div>
        <table class="truth-table" style="max-width: 650px; margin: 0.4em auto;">
          <tr><th>Operation</th><th>Formula</th><th>Why</th></tr>
          <tr><td>a + b</td><td><code>a + b</code></td><td>Scales match</td></tr>
          <tr><td>a &minus; b</td><td><code>a - b</code></td><td>Scales match</td></tr>
          <tr><td>a &times; b</td><td><code>a * b / 1e18</code></td><td>Undo double-scaling</td></tr>
          <tr><td>a &divide; b</td><td><code>a * 1e18 / b</code></td><td>Pre-scale numerator</td></tr>
        </table>
        <aside class="notes">Division is even trickier. 3e18 divided by 2e18 gives you 1 — not 1.5e18! The 18 decimal places cancelled out. Fix: multiply the numerator by 1e18 first, THEN divide. 3e36 / 2e18 = 1.5e18 = 1.5. That table at the bottom is your cheat sheet. Print it out. For addition: just do it. Multiplication: divide by 1e18 at the end. Division: multiply by 1e18 at the start. Mess this up, and you'll either overflow or lose all precision.</aside>
      </section>

      <!-- ============ OVERFLOW DANGER ============ -->
      <section>
        <h2>Danger: Overflow</h2>
        <pre><code class="hljs">// uint256 max = 2^256 - 1 ≈ 1.16 × 10^77

// Multiplying two large fixed-point numbers:
uint256 a = 1000e18; // 1000.0
uint256 b = 1000e18; // 1000.0
// a * b = 1e42 → still fits in uint256 ✓

// But three multiplications chained:
// a * b * c before dividing = 1e63 → might overflow!

// Safe approach: divide between multiplications
uint256 ab = a * b / 1e18;  // 1e42 / 1e18 = 1e24 ✓
uint256 result = ab * c / 1e18; // stays manageable</code></pre>
        <div class="callout-red">
          <strong>Rule of thumb:</strong> always divide by 1e18 <em>between</em> each multiplication, not all at the end.
        </div>
        <p class="subtle">PRBMath handles this for you internally &mdash; that's a big reason to use it.</p>
        <aside class="notes">Fixed-point math has a landmine: overflow. uint256 can hold up to about 1.16 times 10 to the 77th. Sounds huge, but 1e18 times 1e18 is already 1e36. Chain three multiplications and you're at 1e54. Two more and you overflow. The safe pattern: divide by 1e18 after EVERY multiplication, not at the end. PRBMath does this internally — it carefully orders operations to maximize precision while avoiding overflow. That's one of the biggest reasons to use a library instead of rolling your own math.</aside>
      </section>

      <!-- ══════════════════════════════════════════════
           PART 5 — ENTER PRBMath
           ══════════════════════════════════════════════ -->
      <section>
        <h2 style="color:#9b59b6;">Part 5: PRBMath — The Library</h2>
        <p>PRBMath gives you <strong>exp, ln, sqrt, pow, mul, div</strong> — all in fixed-point.</p>
        <div class="two-col">
          <div>
            <h3>Without PRBMath</h3>
            <pre><code class="hljs">// How do you compute e^(0.08)?
// You can't. Solidity has no exp().
// You'd need a Taylor series:
// e^x ≈ 1 + x + x²/2 + x³/6 + ...
// Each term needs careful fixed-point
// mul and div with overflow checks.
// 20+ lines of tricky math code.</code></pre>
          </div>
          <div>
            <h3>With PRBMath</h3>
            <pre><code class="hljs">import {UD60x18, ud, exp}
    from "prb-math/UD60x18.sol";

UD60x18 result = exp(ud(0.08e18));
// result ≈ 1.0833e18
// Done. One line.</code></pre>
          </div>
        </div>
        <div class="callout">
          PRBMath wraps all the overflow-safe, precision-maximizing fixed-point math behind simple function calls.
        </div>
        <aside class="notes">This is why PRBMath exists. Without it, computing e^0.08 in Solidity requires implementing a Taylor series expansion with careful overflow management at every step. That's 20+ lines of code that's easy to get wrong. With PRBMath: one import, one function call. It handles the Taylor series, the overflow protection, the precision optimization — all under the hood. You just call exp() and get the answer.</aside>
      </section>

      <!-- ============ UD60x18 EXPLAINED ============ -->
      <section>
        <h4>UD60x18: The Type</h4>
        <div class="callout-blue">
          <strong>U</strong>nsigned <strong>D</strong>ecimal, <strong>60</strong> integer bits, <strong>18</strong> fractional digits
        </div>
        <ul>
          <li>It's still a <code>uint256</code> under the hood &mdash; just wrapped in a custom type</li>
          <li>The 18 digits = same precision as ERC-20 tokens (ETH has 18 decimals)</li>
          <li>60 integer bits = up to ~1.15 &times; 10<sup>18</sup> before the decimal point</li>
          <li><strong>Unsigned</strong> = no negative numbers (there's SD59x18 for signed)</li>
        </ul>
        <pre><code class="hljs">// UD60x18 is just a wrapper around uint256
type UD60x18 is uint256;

// The "ud" function wraps a raw uint256 into this type
function ud(uint256 x) pure returns (UD60x18) {
    return UD60x18.wrap(x);
}

// The "unwrap" function gets the raw uint256 back
function unwrap(UD60x18 x) pure returns (uint256) {
    return UD60x18.unwrap(x);
}</code></pre>
        <p class="subtle">Think of UD60x18 as a "labeled box" that says "I'm a fixed-point number — use special math on me".</p>
        <aside class="notes">UD60x18 sounds intimidating but it's simple. It's a uint256 that the compiler treats as a special type so you can't accidentally mix it with regular integers. U = unsigned (no negatives), D = decimal, 60 = the integer part can be up to 60 bits wide, 18 = 18 digits of fractional precision. The ud() function is just wrapping: you give it a raw number like 5e17, it wraps it into the UD60x18 type so the compiler knows it's fixed-point. unwrap() does the reverse. That's all the type system magic — the actual number stored in memory is the same uint256.</aside>
      </section>

      <!-- ============ WRAP → MATH → UNWRAP ============ -->
      <section>
        <h2>The Three-Step Pattern</h2>
        <p>Every PRBMath computation follows the same workflow:</p>
        <div style="text-align:center; margin: 0.5em 0;">
          <span class="step-num">1</span> <strong>WRAP</strong> raw numbers into UD60x18
          &nbsp;&nbsp;&rarr;&nbsp;&nbsp;
          <span class="step-num">2</span> <strong>MATH</strong> using library functions
          &nbsp;&nbsp;&rarr;&nbsp;&nbsp;
          <span class="step-num">3</span> <strong>UNWRAP</strong> back to uint256
        </div>
        <pre><code class="hljs">import {UD60x18, ud, unwrap, exp, mul} from "prb-math/UD60x18.sol";

// STEP 1: WRAP — convert raw numbers to fixed-point
UD60x18 base  = ud(0.5e18);   // 0.5 in fixed-point
UD60x18 rate  = ud(0.08e18);  // 0.08 in fixed-point
UD60x18 supply = ud(10e18);   // 10 in fixed-point

// STEP 2: MATH — compute using library functions
UD60x18 exponent = mul(rate, supply);  // 0.08 × 10 = 0.8
UD60x18 growth   = exp(exponent);       // e^0.8 ≈ 2.2255
UD60x18 price    = mul(base, growth);   // 0.5 × 2.2255 ≈ 1.1128

// STEP 3: UNWRAP — get raw uint256 back
uint256 priceWei = unwrap(price);       // ≈ 1_112_749_685_157_800_000</code></pre>
        <div class="callout">
          You never do <code>*</code> or <code>/</code> directly on UD60x18. Always use <code>mul()</code>, <code>div()</code>, <code>exp()</code>, <code>ln()</code>.
        </div>
        <aside class="notes">This is THE pattern you need to memorize. Step 1: take your raw numbers and wrap them with ud(). The number must already be in 1e18 form — so 0.5 becomes 0.5e18, and you write ud(0.5e18). Step 2: use the library's math functions. mul for multiply, div for divide, exp for e-to-the-x, ln for natural log. These functions take UD60x18 and return UD60x18. Step 3: when you need a regular uint256 for storage, comparison, or returning from a function, call unwrap(). Walk through the numbers: 0.08 times 10 equals 0.8. e to the 0.8 is about 2.23. 0.5 times 2.23 is about 1.11. That's the price of the 10th token.</aside>
      </section>

      <!-- ============ PRBMath CHEAT SHEET ============ -->
      <section>
        <h2>PRBMath Cheat Sheet</h2>
        <div class="two-col">
          <div>
            <table class="truth-table">
              <tr><th>Op</th><th>Code</th><th>Example</th></tr>
              <tr><td>Wrap</td><td><code>ud(n)</code></td><td><code>ud(2e18)</code> = 2.0</td></tr>
              <tr><td>Unwrap</td><td><code>unwrap(x)</code></td><td>raw uint256</td></tr>
              <tr><td>a &times; b</td><td><code>mul(a,b)</code></td><td>2.0 &times; 3.0 = 6.0</td></tr>
              <tr><td>a &divide; b</td><td><code>div(a,b)</code></td><td>6.0 &divide; 2.0 = 3.0</td></tr>
            </table>
          </div>
          <div>
            <table class="truth-table">
              <tr><th>Op</th><th>Code</th><th>Example</th></tr>
              <tr><td>e<sup>x</sup></td><td><code>exp(x)</code></td><td>exp(1.0) &asymp; 2.718</td></tr>
              <tr><td>ln(x)</td><td><code>ln(x)</code></td><td>ln(e) &asymp; 1.0</td></tr>
              <tr><td>&radic;x</td><td><code>sqrt(x)</code></td><td>sqrt(4.0) = 2.0</td></tr>
              <tr><td>x<sup>y</sup></td><td><code>pow(x,y)</code></td><td>pow(2.0, 3.0) = 8.0</td></tr>
            </table>
          </div>
        </div>
        <div class="callout">
          <strong>Import:</strong> <code>import {UD60x18, ud, unwrap, exp, ln, mul, div, sqrt, pow} from "prb-math/UD60x18.sol";</code>
        </div>
        <aside class="notes">Keep this slide as a reference. These eight operations cover everything you need for bonding curves. The import line at the bottom pulls them all in at once. Notice: wrap is ud(), unwrap is unwrap(), math operations are function calls not operators. You never use * or / on UD60x18 values — always use mul() and div() which handle the scaling internally. Once this table clicks, you can read any PRBMath contract.</aside>
      </section>

      <!-- ============ HANDS-ON: LINEAR PRICE ============ -->
      <section>
        <h2>Hands-On: Build a Linear Price Function</h2>
        <p class="subtle">Let's build <span class="formula">price(s) = 0.2 &middot; s + 1</span> using PRBMath.</p>
        <pre><code class="hljs">import {UD60x18, ud, unwrap, mul} from "prb-math/UD60x18.sol";

contract LinearPrice {
    UD60x18 public immutable slope; // m = 0.2
    UD60x18 public immutable base;  // b = 1.0

    constructor() {
        slope = ud(0.2e18);  // 0.2 in fixed-point
        base  = ud(1e18);    // 1.0 in fixed-point
    }

    function price(uint256 supply) public view returns (uint256) {
        // Step 1: WRAP supply
        UD60x18 s = ud(supply * 1e18);

        // Step 2: MATH — m * s + b
        UD60x18 ms = mul(slope, s);     // 0.2 × supply
        UD60x18 result = ms + base;     // + operator works for UD60x18 addition!

        // Step 3: UNWRAP
        return unwrap(result);
    }
}

// price(0)  → 1.0e18  (= 1.0 ETH)
// price(10) → 3.0e18  (= 3.0 ETH)
// price(20) → 5.0e18  (= 5.0 ETH)</code></pre>
        <div class="callout-green">
          <strong>Addition works with +</strong> because UD60x18 overloads the operator. Multiplication needs <code>mul()</code>.
        </div>
        <aside class="notes">Let's put it all together. This is a complete, deployable contract. The constructor wraps our slope and base into UD60x18. The price function: wrap the supply, multiply by slope using mul(), add the base using the + operator (UD60x18 overloads + and - but not * and /), then unwrap. Let's check: price(0) = 0.2*0 + 1 = 1.0e18. price(10) = 0.2*10 + 1 = 3.0e18. Correct! This is a real bonding curve. The only thing missing is the mint function that calls this.</aside>
      </section>

      <!-- ============ HANDS-ON: EXPONENTIAL PRICE ============ -->
      <section>
        <h2>Hands-On: Build an Exponential Price Function</h2>
        <p class="subtle"><span class="formula">price(s) = 0.5 &middot; e<sup>0.08&middot;s</sup></span> — the "FOMO curve".</p>
        <pre><code class="hljs">import {UD60x18, ud, unwrap, mul, exp} from "prb-math/UD60x18.sol";

contract ExpoPrice {
    UD60x18 public immutable a; // base = 0.5
    UD60x18 public immutable k; // rate = 0.08

    constructor() {
        a = ud(0.5e18);   // 0.5
        k = ud(0.08e18);  // 0.08
    }

    function price(uint256 supply) public view returns (uint256) {
        // 1. WRAP
        UD60x18 s = ud(supply * 1e18);

        // 2. MATH
        UD60x18 ks    = mul(k, s);       // 0.08 × supply
        UD60x18 expKs = exp(ks);          // e^(0.08 × supply)
        UD60x18 result = mul(a, expKs);   // 0.5 × e^(0.08 × supply)

        // 3. UNWRAP
        return unwrap(result);
    }
}

// price(0)  → 0.5e18    (= 0.50 ETH  — cheap!)
// price(10) → 1.1127e18 (= 1.11 ETH)
// price(50) → 27.29e18  (= 27.29 ETH — expensive!)
// price(100)→ 1490.47e18(= 1490 ETH — insane!)</code></pre>
        <aside class="notes">Now try exponential. Same three steps: wrap, math, unwrap. The key line is exp(ks) — that's e to the power of (0.08 times supply). Look at the price at different supplies: at 0 it's 0.5 ETH, at 10 it's 1.11, at 50 it's 27 ETH, at 100 it's 1490 ETH. That's the power of exponential growth. This is why some projects cap total supply or have a maximum price. Without PRBMath, implementing that exp() would be 50+ lines of Taylor series code.</aside>
      </section>

      <!-- ============ HANDS-ON: LOG PRICE ============ -->
      <section>
        <h2>Hands-On: Build a Logarithmic Price Function</h2>
        <p class="subtle"><span class="formula">price(s) = 2 &middot; ln(s + 1)</span> — the "fair growth" curve.</p>
        <pre><code class="hljs">import {UD60x18, ud, unwrap, mul, ln} from "prb-math/UD60x18.sol";

contract LogPrice {
    UD60x18 public immutable k; // scale = 2.0
    UD60x18 public immutable c; // shift = 1.0 (avoids ln(0))

    constructor() {
        k = ud(2e18);
        c = ud(1e18);
    }

    function price(uint256 supply) public view returns (uint256) {
        // 1. WRAP
        UD60x18 s = ud(supply * 1e18);

        // 2. MATH
        UD60x18 inner = s + c;            // supply + 1 (avoids ln(0)!)
        UD60x18 logVal = ln(inner);        // ln(supply + 1)
        UD60x18 result = mul(k, logVal);   // 2 × ln(supply + 1)

        // 3. UNWRAP
        return unwrap(result);
    }
}

// price(0)  → 0.00e18  (= 0 ETH — free!)
// price(1)  → 1.39e18  (= 1.39 ETH — quick rise)
// price(10) → 4.79e18  (= 4.79 ETH)
// price(100)→ 9.23e18  (= 9.23 ETH — barely moved!)
// price(1000)→13.82e18 (= 13.82 ETH — still gentle)</code></pre>
        <aside class="notes">Logarithmic is the gentle curve. Same pattern, but we use ln() instead of exp(). Critical detail: we add c=1 before taking ln, because ln(0) is negative infinity — it would crash. Look at the prices: 0 to 10 supply gains 4.79 ETH of price. But 100 to 1000 supply only gains 4.59 more. The curve is flattening out. Perfect for utility tokens where early adopters get rewarded but the price stabilizes over time.</aside>
      </section>

      <!-- ============ COMMON MISTAKES ============ -->
      <section>
        <h2>Common PRBMath Mistakes</h2>
        <table class="truth-table">
          <tr><th>Mistake</th><th>What Happens</th><th>Fix</th></tr>
          <tr>
            <td><code>ud(10)</code> instead of <code>ud(10e18)</code></td>
            <td>Wraps 10 as 0.00000000000000001</td>
            <td>Always multiply by 1e18 first</td>
          </tr>
          <tr>
            <td><code>a * b</code> on UD60x18</td>
            <td>Compiler error (no * operator)</td>
            <td>Use <code>mul(a, b)</code></td>
          </tr>
          <tr>
            <td><code>ln(ud(0))</code></td>
            <td>Reverts (ln(0) = -∞)</td>
            <td>Add shift: <code>ln(s + c)</code></td>
          </tr>
          <tr>
            <td>Forgetting <code>unwrap()</code></td>
            <td>Type mismatch: UD60x18 vs uint256</td>
            <td>Unwrap before returning/comparing</td>
          </tr>
          <tr>
            <td><code>exp(ud(100e18))</code></td>
            <td>Overflow (e^100 is astronomical)</td>
            <td>Keep exponents small (&lt; 133e18)</td>
          </tr>
        </table>
        <div class="callout-red">
          <strong>#1 mistake:</strong> forgetting the <code>e18</code> when wrapping. <code>ud(5)</code> &ne; <code>ud(5e18)</code>!
        </div>
        <aside class="notes">Let me save you hours of debugging. Mistake #1: ud(10) — this wraps the raw integer 10, which in fixed-point means 0.00000000000000001, not 10.0. You need ud(10e18). Mistake #2: using the star operator — UD60x18 supports + and - but NOT * and /. Use mul() and div(). Mistake #3: ln(0) — this is mathematically undefined and will revert. Always add a shift. Mistake #4: returning a UD60x18 when the function signature says uint256 — the compiler will catch this but it's confusing. Mistake #5: exp() of a huge number — e^100 is about 2.7 × 10^43, which when scaled by 1e18 can overflow. Keep exponents under about 133.</aside>
      </section>
      <!-- ══════════════════════════════════════════════
           PART II — PRBMATH INTERNALS
           ══════════════════════════════════════════════ -->
      <section>
        <h1>Part II: PRBMath Internals</h1>
        <h3>How the Math Actually Works Under the Hood</h3>
        <p class="subtle">Now that we know how to USE PRBMath, let's open the hood and read the source code.</p>
        <aside class="notes">We've learned to use PRBMath: wrap, call, unwrap. Now we open the hood and read the actual source code. By the end, you'll understand every technique PRBMath uses and why each exists.</aside>
      </section>



      <section>
        <h2>What We'll Cover</h2>
        <div class="two-col">
          <div>
            <p><span class="step-num">6</span> Repo Architecture &amp; Types</p>
            <p><span class="step-num">7</span> <code>mul()</code> — Phantom Overflow</p>
            <p><span class="step-num">8</span> <code>div()</code> — Scale-First Pattern</p>
            <p><span class="step-num">9</span> <code>mulDiv()</code> — The 512-bit Core</p>
          </div>
          <div>
            <p><span class="step-num">10</span> <code>exp()</code> — Bit Decomposition</p>
            <p><span class="step-num">11</span> <code>ln()</code> — Binary Logarithm</p>
            <p><span class="step-num">12</span> <code>sqrt()</code> — Newton's Method</p>
            <p><span class="step-num">13</span> <code>pow()</code> &amp; Gas Costs</p>
          </div>
        </div>
        <div class="callout">
          <strong>Goal:</strong> Read PRBMath source code confidently. Know <em>why</em> each trick is needed, not just <em>what</em> it does.
        </div>
      </section>

      <!-- ══════════════════════════════════════════════
           PART 6 — REPO ARCHITECTURE
           ══════════════════════════════════════════════ -->
      <section>
        <h2 style="color:#e67e22;">Part 6: Repo Architecture</h2>
        <p>PRBMath v4 — <code>github.com/PaulRBerg/prb-math</code></p>
      </section>

      <section>
        <h2>Two Type Families</h2>
        <div class="two-col">
          <div>
            <h3 style="color:#2d9cdb;">UD60x18</h3>
            <p><strong>U</strong>nsigned <strong>D</strong>ecimal</p>
            <p>60 integer digits, 18 decimals</p>
            <p>Range: 0 → ~1.16 × 10<sup>59</sup></p>
            <pre><code class="hljs">type UD60x18 is uint256;
// 1.0 = 1_000_000_000_000_000_000
// stored as a plain uint256</code></pre>
          </div>
          <div>
            <h3 style="color:#e74c3c;">SD59x18</h3>
            <p><strong>S</strong>igned <strong>D</strong>ecimal</p>
            <p>59 integer digits, 18 decimals</p>
            <p>Range: ~-5.8 × 10<sup>58</sup> → +5.8 × 10<sup>58</sup></p>
            <pre><code class="hljs">type SD59x18 is int256;
// -1.0 = -1_000_000_000_000_000_000
// uses two's complement</code></pre>
          </div>
        </div>
        <div class="callout">
          Both are <strong>user-defined value types</strong> (Solidity 0.8.8+). Zero runtime cost — just a <code>uint256</code> / <code>int256</code> underneath.
        </div>
        <aside class="notes">A user-defined value type in Solidity is like a strong typedef. The compiler treats UD60x18 and uint256 as different types, so you can't accidentally mix them. But at the EVM level, they're identical — no extra storage, no extra gas for the wrapping. The 60x18 means: up to 60 digits before the decimal and 18 after. SD59x18 loses one digit for the sign bit.</aside>
      </section>

      <section>
        <h2>File Structure (v4)</h2>
        <pre><code class="hljs">prb-math/
├── src/
│   ├── Common.sol          ← mulDiv, mulDiv18, sqrt (shared)
│   ├── ud60x18/
│   │   ├── Casting.sol     ← wrap(), unwrap(), ud()
│   │   ├── Constants.sol   ← UNIT, MAX, PI, E
│   │   ├── Conversions.sol ← convert(), from UD to SD
│   │   ├── Errors.sol      ← PRBMath_UD60x18_*
│   │   ├── Helpers.sol     ← add, sub (using + -)
│   │   ├── Math.sol        ← mul, div, exp, exp2, ln,
│   │   │                      log2, log10, sqrt, pow, avg
│   │   └── ValueType.sol   ← type UD60x18 is uint256
│   └── sd59x18/            ← (mirrors ud60x18 structure)
└── test/</code></pre>
        <div class="callout">
          We'll focus on <strong>Common.sol</strong> and <strong>ud60x18/Math.sol</strong> — that's where all the algorithms live.
        </div>
        <aside class="notes">The repo is cleanly organized. Common.sol contains functions shared between UD60x18 and SD59x18 — like mulDiv and sqrt. The type-specific Math.sol files contain the fixed-point aware wrappers. We'll read UD60x18 today since it's simpler (no sign handling).</aside>
      </section>

      <section>
        <h2>The UNIT Constant</h2>
        <pre><code class="hljs">/// @dev The unit number, which gives the decimal precision of UD60x18.
uint256 constant uUNIT = 1e18;
UD60x18 constant UNIT = UD60x18.wrap(1e18);</code></pre>
        <p>Every function in PRBMath revolves around this single idea:</p>
        <p class="formula-lg">real_value = stored_uint256 / 10<sup>18</sup></p>
        <div class="two-col">
          <div>
            <table class="truth-table">
              <tr><th>Real Value</th><th>Stored uint256</th></tr>
              <tr><td>1.0</td><td>1_000_000_000_000_000_000</td></tr>
              <tr><td>3.14</td><td>3_140_000_000_000_000_000</td></tr>
              <tr><td>0.001</td><td>1_000_000_000_000_000</td></tr>
            </table>
          </div>
          <div>
            <div class="callout-green">
              <strong>Why 10<sup>18</sup>?</strong> Matches ETH's <code>wei</code> precision. 1 ETH = 10<sup>18</sup> wei. No conversion needed when working with token amounts.
            </div>
          </div>
        </div>
        <aside class="notes">The entire library is built on one convention: multiply your real number by 10^18. This gives you 18 decimal places of precision — more than enough for financial math. The choice of 10^18 (not 10^27 like RAY in MakerDAO) matches Ethereum's native wei denomination, making conversions between ETH amounts and UD60x18 values trivial.</aside>
      </section>

      <!-- ══════════════════════════════════════════════
           PART 7 — mul() INTERNALS
           ══════════════════════════════════════════════ -->
      <section>
        <h2 style="color:#27ae60;">Part 7: <code>mul()</code> — Phantom Overflow</h2>
        <p>The simplest operation reveals the deepest trick.</p>
      </section>

      <section>
        <h2>The Problem with Naive Multiply</h2>
        <pre><code class="hljs">// ❌ WRONG — overflows!
function naiveMul(UD60x18 x, UD60x18 y) pure returns (UD60x18) {
    return UD60x18.wrap(
        UD60x18.unwrap(x) * UD60x18.unwrap(y) / 1e18
    );
}

// x = 2.0 → stored as 2e18
// y = 3.0 → stored as 3e18
// x * y = 2e18 * 3e18 = 6e36  ← PHANTOM OVERFLOW!
// 6e36 / 1e18 = 6e18 = 6.0   ← correct answer…
//                              IF it doesn't overflow first</code></pre>
        <div class="callout-red">
          <strong>Phantom overflow:</strong> the intermediate <code>x * y</code> value exceeds uint256 even though the final result fits. <code>uint256.max ≈ 1.16e77</code>, but two large UD60x18 values multiplied can reach <code>~1.34e77</code>.
        </div>
        <aside class="notes">This is the fundamental problem of fixed-point multiplication. When you multiply two 18-decimal numbers, the intermediate result has 36 decimals — way more precision than needed, and potentially enough to overflow. The real answer is small and correct, but the intermediate value is huge. That's phantom overflow: the overflow is an artifact of the computation order, not the actual result size. PRBMath solves this with mulDiv.</aside>
      </section>

      <section>
        <h2>PRBMath's <code>mul()</code> — Actual Source</h2>
        <pre><code class="hljs">/// @notice Multiplies two UD60x18 numbers together,
/// returning a new UD60x18 number.
function mul(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {
    result = wrap(mulDiv18(unwrap(x), unwrap(y)));
}</code></pre>
        <p>Just 1 line! The real work is in <span class="fn-name">mulDiv18</span>.</p>
        <div class="callout">
          <code>mulDiv18(a, b)</code> computes <code>(a × b) / 1e18</code> without intermediate overflow.<br>
          It's a specialized version of the general <code>mulDiv(a, b, denominator)</code>.
        </div>
        <aside class="notes">The mul function itself is beautifully simple — unwrap both inputs, call mulDiv18, wrap the result. All the complexity is pushed down into mulDiv18, which is in Common.sol. mulDiv18 is optimized specifically for division by 1e18, while the general mulDiv handles any denominator. Let's look at mulDiv next.</aside>
      </section>

      <!-- ══════════════════════════════════════════════
           PART 8 — div() INTERNALS
           ══════════════════════════════════════════════ -->
      <section>
        <h2 style="color:#2d9cdb;">Part 8: <code>div()</code> — Scale First</h2>
        <p>Division has the <em>opposite</em> problem of multiplication.</p>
      </section>

      <section>
        <h2>The Problem with Naive Division</h2>
        <pre><code class="hljs">// ❌ WRONG — loses ALL precision!
function naiveDiv(UD60x18 x, UD60x18 y) pure returns (UD60x18) {
    return UD60x18.wrap(
        UD60x18.unwrap(x) / UD60x18.unwrap(y)
    );
}

// x = 1.0 → stored as 1e18
// y = 3.0 → stored as 3e18
// x / y = 1e18 / 3e18 = 0     ← integer division truncates!
// Expected: 0.333...e18</code></pre>
        <div class="callout-red">
          <strong>Precision loss:</strong> dividing two same-scale numbers cancels out the scale factor, giving you an unscaled integer (often 0).
        </div>
      </section>

      <section>
        <h2>PRBMath's <code>div()</code> — Scale First</h2>
        <pre><code class="hljs">/// @notice Divides two UD60x18 numbers, returning a UD60x18 number.
function div(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {
    result = wrap(mulDiv(unwrap(x), uUNIT, unwrap(y)));
}</code></pre>
        <p>Trick: compute <code>(x × 1e18) / y</code> instead of <code>x / y</code>.</p>
        <div class="two-col">
          <div>
            <h3>Step by step</h3>
            <p><span class="step-num">1</span> x = 1e18 (represents 1.0)</p>
            <p><span class="step-num">2</span> Multiply by 1e18 → 1e36</p>
            <p><span class="step-num">3</span> Divide by 3e18 → 333...e15</p>
            <p><span class="step-num">4</span> Result ≈ 0.333e18 ✓</p>
          </div>
          <div>
            <div class="callout-green">
              By scaling up <em>before</em> dividing, we preserve 18 decimals of precision. And <code>mulDiv</code> ensures the intermediate <code>x × 1e18</code> doesn't overflow.
            </div>
          </div>
        </div>
        <aside class="notes">This is the mirror image of the mul problem. In mul, the intermediate is too big. In div, the intermediate is too small (we lose precision). The fix: multiply by the UNIT first to add scale, THEN divide. But now we have the same phantom overflow problem — x times 1e18 could overflow! So div also uses mulDiv under the hood. Everything routes through mulDiv.</aside>
      </section>

      <!-- ══════════════════════════════════════════════
           PART 9 — mulDiv() — THE HEART
           ══════════════════════════════════════════════ -->
      <section>
        <h2 style="color:#e74c3c;">Part 9: <code>mulDiv()</code> — The 512-bit Heart</h2>
        <p>The most important function in PRBMath.</p>
        <p class="subtle">~80 lines of Yul assembly that make everything else possible.</p>
      </section>

      <section>
        <h2>mulDiv — What It Computes</h2>
        <p class="formula-lg">mulDiv(x, y, d) = ⌊(x × y) / d⌋</p>
        <p>…without intermediate overflow, even when <code>x × y</code> exceeds uint256!</p>
        <div class="callout">
          <strong>Key insight:</strong> use a <strong>512-bit intermediate</strong>. The EVM is 256-bit, so PRBMath simulates 512-bit math using two uint256 variables: <code>prod0</code> (low bits) and <code>prod1</code> (high bits).
        </div>
        <p class="subtle">Based on Remco Bloemen's algorithm & "Hacker's Delight" by Henry S. Warren.</p>
        <aside class="notes">mulDiv is the mathematical core of PRBMath. Every other function — mul, div, exp, ln, pow — eventually calls mulDiv. It computes (x * y) / d with full 512-bit precision on the intermediate product. This is non-trivial: the EVM only has 256-bit arithmetic. PRBMath uses a technique from Remco Bloemen (an Ethereum researcher) that splits the 512-bit product into two 256-bit halves and performs division on the combined value. The algorithm draws on tricks from Hacker's Delight, a famous book of bit-manipulation algorithms.</aside>
      </section>

      <section>
        <h2>mulDiv — Step 1: 512-bit Product</h2>
        <pre><code class="hljs">// Compute the 512-bit product [prod1 prod0]
uint256 prod0;  // low  256 bits of x * y
uint256 prod1;  // high 256 bits of x * y
assembly {
    let mm := mulmod(x, y, not(0))  // x*y mod 2^256
    prod0 := mul(x, y)              // low bits (wraps)
    prod1 := sub(sub(mm, prod0), lt(mm, prod0))
}</code></pre>
        <div class="two-col">
          <div>
            <p><span class="step-num">1</span> <code>mul(x,y)</code> gives low 256 bits (EVM wraps)</p>
            <p><span class="step-num">2</span> <code>mulmod(x,y,2²⁵⁶-1)</code> gives <code>x*y mod (2²⁵⁶-1)</code></p>
            <p><span class="step-num">3</span> Subtract to get <code>prod1</code> (high bits)</p>
          </div>
          <div>
            <div class="callout-blue">
              <strong>Why mulmod?</strong> The EVM <code>MULMOD</code> opcode internally uses a 512-bit intermediate — PRBMath exploits this to extract the high bits!
            </div>
          </div>
        </div>
        <aside class="notes">This is the cleverest part. The EVM's MUL opcode returns the low 256 bits of the product (it wraps on overflow). But the MULMOD opcode internally computes the full 512-bit product before taking the modulus. By using mulmod with a modulus of 2^256-1 (not(0) in Yul), we get almost the full product. The difference between mulmod result and mul result, with a borrow correction, gives us the high 256 bits. So we reconstruct the full 512-bit product using only standard EVM opcodes. Pure genius.</aside>
      </section>

      <section>
        <h2>mulDiv — Step 2: Fast Path</h2>
        <pre><code class="hljs">// Handle cases where product fits in 256 bits
if (prod1 == 0) {
    return prod0 / denominator;
}</code></pre>
        <div class="callout-green">
          If <code>prod1 == 0</code>, the product fits in 256 bits. Just do a normal division. This is the <strong>common case</strong> for small-to-medium values — almost free! <span class="gas-tag">~40 gas</span>
        </div>
        <p>The expensive path (below) only runs when values are large enough to actually overflow 256 bits.</p>
        <aside class="notes">This is an important optimization. Most of the time in practice, x * y fits in 256 bits. The 512-bit slow path only activates when dealing with genuinely large numbers — like multiplying two values that are each over 10^38. The fast path costs about 40 gas, while the full 512-bit path costs around 140 gas.</aside>
      </section>

      <section>
        <h2>mulDiv — Step 3: 512-bit Division</h2>
        <p>When <code>prod1 > 0</code>, things get interesting:</p>
        <pre><code class="hljs">// Make sure the result is less than 2^256
require(denominator > prod1);

// Subtract 256 bit number from 512 bit number
assembly {
    // Compute remainder using mulmod
    let remainder := mulmod(x, y, denominator)
    // Subtract remainder from 512-bit product
    prod1 := sub(prod1, gt(remainder, prod0))
    prod0 := sub(prod0, remainder)
}</code></pre>
        <div class="callout">
          After subtracting the remainder, <code>[prod1:prod0]</code> is now evenly divisible by <code>denominator</code>. The problem reduces to dividing a 512-bit number by a 256-bit divisor.
        </div>
        <aside class="notes">The algorithm first checks that the result will fit in 256 bits (denominator must be bigger than prod1). Then it computes the remainder of the 512-bit product divided by the denominator, using the mulmod opcode again. By subtracting this remainder from the 512-bit product, we get a value that divides evenly — no fractional bits lost. Now we need to perform the actual 512-bit division.</aside>
      </section>

      <section>
        <h2>mulDiv — Step 4: Factor Out Powers of 2</h2>
        <pre><code class="hljs">// Factor powers of two out of denominator
// Compute largest power of two divisor of denominator.
uint256 twos = denominator & (~denominator + 1);
assembly {
    // Divide denominator by twos
    denominator := div(denominator, twos)
    // Divide [prod1:prod0] by twos
    prod0 := div(prod0, twos)
    // Flip twos such that it is 2^256 / twos.
    // If twos is zero, then it becomes one.
    twos := add(div(sub(0, twos), twos), 1)
}
// Shift bits from prod1 into prod0
prod0 |= prod1 * twos;</code></pre>
        <div class="callout">
          <code>twos = d & (-d)</code> isolates the lowest set bit — a classic Hacker's Delight trick. This factors out all powers of 2 from the denominator, simplifying the division.
        </div>
        <aside class="notes">This uses a famous bit manipulation trick: x & (-x) gives you the lowest set bit of x, which equals the largest power of 2 that divides x. By dividing both the denominator and the 512-bit product by this power of 2, we make the denominator odd. Why? Because the next step — modular inverse — only works on odd numbers. The shift from prod1 into prod0 is transferring the remaining high bits after the power-of-2 division.</aside>
      </section>

      <section>
        <h2>mulDiv — Step 5: Modular Inverse</h2>
        <pre><code class="hljs">// Compute the modular inverse of denominator mod 2^256
// using Newton-Raphson iteration.
// Start with a seed that is correct for four bits.
uint256 inverse = (3 * denominator) ^ 2;

// Use Newton-Raphson to double precision each step
inverse *= 2 - denominator * inverse; // 8  bits
inverse *= 2 - denominator * inverse; // 16 bits
inverse *= 2 - denominator * inverse; // 32 bits
inverse *= 2 - denominator * inverse; // 64 bits
inverse *= 2 - denominator * inverse; // 128 bits
inverse *= 2 - denominator * inverse; // 256 bits

// Final result
result = prod0 * inverse;</code></pre>
        <div class="callout-green">
          Division by <code>d</code> becomes <strong>multiplication by d's modular inverse</strong>. 6 multiplications instead of an expensive division. Each iteration doubles the precision.
        </div>
        <aside class="notes">This is the most magical part. Instead of actually dividing a 512-bit number (which the EVM can't do), PRBMath converts the division into a multiplication by the modular inverse. The modular inverse of d modulo 2^256 is a number inv such that d * inv = 1 (mod 2^256). Newton-Raphson iteration is used to compute this inverse: starting from a 4-bit seed, each step doubles the number of correct bits. After 6 iterations, all 256 bits are correct. Then result = prod0 * inverse gives us the exact quotient. This works because after step 4, the denominator is odd (required for the modular inverse to exist) and prod0 contains the correctly shifted product. The cost is just 6 multiplications plus a few additions — much cheaper than a 512-bit division circuit.</aside>
      </section>

      <section>
        <h2>mulDiv — Complete Picture</h2>
        <div class="three-col">
          <div>
            <p><span class="step-num">1</span> <strong>512-bit multiply</strong></p>
            <p class="subtle">Use MULMOD to get high bits</p>
            <p><span class="step-num">2</span> <strong>Fast path check</strong></p>
            <p class="subtle">prod1 == 0 → normal div</p>
          </div>
          <div>
            <p><span class="step-num">3</span> <strong>Subtract remainder</strong></p>
            <p class="subtle">Make evenly divisible</p>
            <p><span class="step-num">4</span> <strong>Factor out 2's</strong></p>
            <p class="subtle">d &amp; (-d) trick</p>
          </div>
          <div>
            <p><span class="step-num">5</span> <strong>Modular inverse</strong></p>
            <p class="subtle">Newton-Raphson × 6 iter</p>
            <p><span class="step-num">6</span> <strong>Multiply</strong></p>
            <p class="subtle">prod0 × inverse = result</p>
          </div>
        </div>
        <div class="callout">
          <strong>Gas cost:</strong> ~140 gas for the full 512-bit path, ~40 gas for the fast path. <br>
          For comparison: a single <code>SSTORE</code> is 20,000 gas. mulDiv is <em>cheap</em>.
        </div>
        <aside class="notes">Let's recap the full mulDiv algorithm. Step 1: compute the 512-bit product using MUL and MULMOD. Step 2: if it fits in 256 bits, just divide normally. Step 3: subtract the remainder so the number divides evenly. Step 4: factor out powers of 2 using the classic bit trick. Step 5: compute the modular inverse using Newton-Raphson. Step 6: multiply by the inverse to get the final result. All of this costs roughly 140 gas — less than 1% of a storage write. It's an absolute masterpiece of gas-optimized math.</aside>
      </section>

      <!-- ══════════════════════════════════════════════
           PART 10 — exp() INTERNALS
           ══════════════════════════════════════════════ -->
      <section>
        <h2 style="color:#9b59b6;">Part 10: <code>exp()</code> — Computing e<sup>x</sup></h2>
        <p>The hardest function. No Taylor series — too expensive.</p>
      </section>

      <section>
        <h2>exp() Strategy: Change of Base</h2>
        <p>PRBMath does <strong>not</strong> compute e<sup>x</sup> directly. Instead:</p>
        <p class="formula-lg">e<sup>x</sup> = 2<sup>x × log₂(e)</sup></p>
        <div class="two-col">
          <div>
            <div class="callout-red">
              <strong>❌ Taylor series</strong><br>
              e<sup>x</sup> = 1 + x + x²/2! + x³/3! + ...<br>
              Needs ~20 terms → 20 mulDivs → ~3000 gas
            </div>
          </div>
          <div>
            <div class="callout-green">
              <strong>✓ Base-2 decomposition</strong><br>
              Convert to <code>exp2()</code> which uses bit tricks<br>
              Much fewer operations → ~1600 gas
            </div>
          </div>
        </div>
        <pre><code class="hljs">function exp(UD60x18 x) pure returns (UD60x18 result) {
    // x_192x64 = x * log2(e), scaled to 192.64 format
    // then call exp2()
    result = wrap(exp2(mulDiv18(unwrap(x), uLOG2_E)));
}</code></pre>
        <aside class="notes">Computing e^x using a Taylor series would require about 20 terms to get 18 digits of precision. Each term needs a mulDiv operation. Instead, PRBMath uses a change of base: e^x equals 2^(x * log2(e)). The log2(e) is a precomputed constant. Then it computes 2^y using exp2(), which exploits the binary nature of the exponent. This is much faster because computing powers of 2 maps directly to bit operations.</aside>
      </section>

      <section>
        <h2>exp2() — The Bit Decomposition Trick</h2>
        <p>To compute <code>2<sup>y</sup></code>, split y into integer + fraction:</p>
        <p class="formula">2<sup>5.75</sup> = 2<sup>5</sup> × 2<sup>0.75</sup></p>
        <div class="two-col">
          <div>
            <h3>Integer part: <code>2<sup>5</sup></code></h3>
            <pre><code class="hljs">// Just a bit shift!
result = 1 << integerPart;
// 2^5 = 32 = 1 << 5
// Cost: 3 gas (SHL opcode)</code></pre>
          </div>
          <div>
            <h3>Fractional part: <code>2<sup>0.75</sup></code></h3>
            <p class="subtle">This is the hard part. PRBMath uses a product of precomputed factors.</p>
            <pre><code class="hljs">// 0.75 in binary = 0.110000...
// 2^0.75 = 2^0.5 × 2^0.25
//        = √2   × ⁴√2</code></pre>
          </div>
        </div>
        <div class="callout">
          <strong>Key insight:</strong> any binary fraction is a sum of negative powers of 2. So 2<sup>frac</sup> = product of precomputed 2<sup>1/2ⁿ</sup> values for each set bit.
        </div>
        <aside class="notes">This is the breakthrough that makes exp2 fast. Every number has a binary representation. The integer part of the exponent is trivial — just a left shift, which is a single EVM opcode. For the fractional part, we express it in binary. Each bit position corresponds to a power: 2^(1/2), 2^(1/4), 2^(1/8), etc. PRBMath precomputes and hardcodes all these values. For each set bit in the fractional part, we multiply by the corresponding precomputed factor. With 64 bits of fraction, we need at most 64 multiplications — but in practice, most bits are zero, and the constants are hardcoded right in the source.</aside>
      </section>

      <section>
        <h2>exp2() — Actual Code (Simplified)</h2>
        <pre><code class="hljs">// The fractional part in 192.64-bit fixed-point
uint256 x = xValue;  // the fractional bits

// For each bit position, multiply by precomputed 2^(1/2^n)
if (x & 0x8000000000000000 > 0)    // bit 63: 2^(1/2)
    result = (result * 0x16A09E667F3BCC909) >> 64;
if (x & 0x4000000000000000 > 0)    // bit 62: 2^(1/4)
    result = (result * 0x1306FE0A31B7152DF) >> 64;
if (x & 0x2000000000000000 > 0)    // bit 61: 2^(1/8)
    result = (result * 0x1172B83C7D517ADCE) >> 64;
if (x & 0x1000000000000000 > 0)    // bit 60: 2^(1/16)
    result = (result * 0x10B5586CF9890F62A) >> 64;
// ... continues for all 64 bits ...
if (x & 0x2 > 0)                   // bit 1: 2^(1/2^63)
    result = (result * 0x10000000000000001) >> 64;
if (x & 0x1 > 0)                   // bit 0: 2^(1/2^64)
    result = (result * 0x10000000000000001) >> 64;</code></pre>
        <div class="callout">
          64 <code>if</code> checks, each with 1 multiply + 1 shift. No loops, no branches — pure branchless math. <span class="gas-tag">~1500 gas total</span>
        </div>
        <aside class="notes">This is what the actual code looks like. Each line checks one bit of the fractional exponent. If the bit is set, it multiplies the running result by the precomputed constant for that bit position. The constants like 0x16A09E667F3BCC909 are 2^(1/2) in 64.64 fixed-point format. Each multiply-and-shift costs about 8 gas. With 64 potential multiplications, the worst case is about 512 gas just for the multiplications. In practice, many bits are zero, so the actual cost is lower. The code looks repetitive, but that's the point — no loops means no jump opcodes, no loop counters, maximum predictability for the EVM.</aside>
      </section>

      <!-- ══════════════════════════════════════════════
           PART 11 — ln() INTERNALS
           ══════════════════════════════════════════════ -->
      <section>
        <h2 style="color:#e67e22;">Part 11: <code>ln()</code> — Binary Logarithm</h2>
        <p>Same trick in reverse: <code>ln(x) = log₂(x) / log₂(e)</code></p>
      </section>

      <section>
        <h2>ln() → log2() → Bit Extraction</h2>
        <pre><code class="hljs">function ln(UD60x18 x) pure returns (UD60x18 result) {
    // ln(x) = log2(x) / log2(e)
    // But we compute: log2(x) * (1/log2(e)) = log2(x) * ln(2)
    unchecked {
        result = wrap(mulDiv(log2(unwrap(x)), uLOG2_E_INV, uUNIT));
    }
}</code></pre>
        <p>Just like exp() delegates to exp2(), ln() delegates to <span class="fn-name">log2()</span>.</p>
        <div class="callout">
          <code>log2()</code> is where the real algorithm lives. It finds the binary logarithm by extracting bits one at a time — from integer part down to fractional part.
        </div>
        <aside class="notes">The pattern should look familiar by now. Just as exp converts to base 2, ln converts to log base 2. The natural log of x equals log2(x) times ln(2), where ln(2) is a precomputed constant. So we just need an efficient log2 implementation. And log2 can be computed using a very elegant bit-extraction algorithm.</aside>
      </section>

      <section>
        <h2>log2() — Integer Part</h2>
        <pre><code class="hljs">// n = integer part of log2(x)
// Find the highest set bit using binary search
uint256 n;
if (xUint >= 2**128) { xUint >>= 128; n += 128; }
if (xUint >= 2**64)  { xUint >>= 64;  n += 64;  }
if (xUint >= 2**32)  { xUint >>= 32;  n += 32;  }
if (xUint >= 2**16)  { xUint >>= 16;  n += 16;  }
if (xUint >= 2**8)   { xUint >>= 8;   n += 8;   }
if (xUint >= 2**4)   { xUint >>= 4;   n += 4;   }
if (xUint >= 2**2)   { xUint >>= 2;   n += 2;   }
if (xUint >= 2**1)   { n += 1; }</code></pre>
        <div class="callout-green">
          <strong>Binary search for the highest set bit</strong> — finds floor(log₂(x)) in exactly 8 comparisons. This is the same algorithm the EVM itself uses internally. <span class="gas-tag">~80 gas</span>
        </div>
        <aside class="notes">The integer part of log2 is just the position of the highest set bit. Finding it with a linear scan would take up to 256 comparisons. Instead, PRBMath uses a binary search: first check if x is at least 2^128, then 2^64, and so on. Each step narrows the range by half. After 8 comparisons, we know the exact bit position. This is O(log(256)) = O(8) — very efficient.</aside>
      </section>

      <section>
        <h2>log2() — Fractional Part</h2>
        <pre><code class="hljs">// y = x / 2^n  (normalize to range [1, 2))
// Now compute fractional bits by repeated squaring
int256 resultInt;
// ...after integer part calculation...

// Compute 64 fractional bits, one at a time
y = (y * y) >> 127;        // square and check
if (y >= 2 * UNIT) {       // if ≥ 2.0...
    resultInt |= (1 << 63); // ...set bit 63
    y >>= 1;               // normalize back
}
y = (y * y) >> 127;
if (y >= 2 * UNIT) {
    resultInt |= (1 << 62); // set bit 62
    y >>= 1;
}
// ... repeat for all 64 bits ...</code></pre>
        <div class="callout">
          <strong>Repeated squaring:</strong> if y² ≥ 2, then the next log₂ bit is 1 (divide by 2 and continue). Otherwise it's 0. One bit per iteration, 64 iterations for 64-bit precision.
        </div>
        <aside class="notes">Once we have the integer part, we normalize x to the range [1, 2) by dividing by 2^n. Now we need the fractional bits of log2. The algorithm: square the number. If the result is ≥ 2, then the next fractional bit is 1 — halve the result and continue. If the result is < 2, the next bit is 0 — continue. This is based on the identity: log2(x) = 2*log2(√x), or equivalently, squaring the input doubles the logarithm. Each squaring exposes one more bit of precision. After 64 squarings, we have 64 fractional bits — more than enough for 18 decimal digits.</aside>
      </section>

      <!-- ══════════════════════════════════════════════
           PART 12 — sqrt() INTERNALS
           ══════════════════════════════════════════════ -->
      <section>
        <h2 style="color:#27ae60;">Part 12: <code>sqrt()</code> — Newton's Method</h2>
        <p>The oldest algorithm in PRBMath — over 3,000 years old.</p>
      </section>

      <section>
        <h2>sqrt() — The Babylonian Method</h2>
        <p>To find √x, repeatedly improve a guess: <span class="formula">g' = (g + x/g) / 2</span></p>
        <pre><code class="hljs">function sqrt(uint256 x) pure returns (uint256 result) {
    if (x == 0) return 0;

    // Initial guess: closest power of 2 to √x
    // (uses the same binary search as log2)
    result = 1;
    uint256 xAux = x;
    if (xAux >= 2**128) { xAux >>= 128; result <<= 64; }
    if (xAux >= 2**64)  { xAux >>= 64;  result <<= 32; }
    if (xAux >= 2**32)  { xAux >>= 32;  result <<= 16; }
    if (xAux >= 2**16)  { xAux >>= 16;  result <<= 8; }
    if (xAux >= 2**8)   { xAux >>= 8;   result <<= 4; }
    if (xAux >= 2**4)   { xAux >>= 4;   result <<= 2; }
    if (xAux >= 2**2)   { result <<= 1; }

    // Newton-Raphson: 7 iterations (doubles bits each time)
    result = (result + x / result) >> 1; // ~8 bits
    result = (result + x / result) >> 1; // ~16 bits
    result = (result + x / result) >> 1; // ~32 bits
    result = (result + x / result) >> 1; // ~64 bits
    result = (result + x / result) >> 1; // ~128 bits
    result = (result + x / result) >> 1; // ~256 bits
    result = (result + x / result) >> 1; // exact

    // Round down
    if (result > x / result) result = x / result;
}</code></pre>
        <aside class="notes">The Babylonian method (also called Newton's method for square roots) is ancient — Babylonian mathematicians used it 3000+ years ago. The idea: start with a guess g. If g is too large, then x/g is too small, and vice versa. Their average (g + x/g)/2 is always closer to the true root. Newton-Raphson iteration doubles the correct bits each step. Starting from an 8-bit initial guess (from the binary search), 7 iterations gives us 256-bit precision. The final check rounds down to ensure we never overestimate.</aside>
      </section>

      <section>
        <h2>sqrt() for UD60x18 — Scale Adjustment</h2>
        <pre><code class="hljs">/// @notice Calculates the square root of x using the
/// Babylonian method.
function sqrt(UD60x18 x) pure returns (UD60x18 result) {
    uint256 xUint = unwrap(x);
    if (xUint > uMAX_UD60x18 / uUNIT) revert ...;
    // Multiply by UNIT (1e18) for scale adjustment,
    // then take integer sqrt
    result = wrap(prbSqrt(xUint * uUNIT));
}</code></pre>
        <div class="two-col">
          <div>
            <h3>Why multiply by 1e18?</h3>
            <p class="subtle">√(x × 1e18) = √x × √(1e18) = √x × 1e9</p>
            <p class="subtle">But we need √x × 1e18 (UD60x18 format).</p>
            <p class="subtle">So: √(x × 1e18 × 1e18) = √(x × 1e36) = √x × 1e18 ✓</p>
          </div>
          <div>
            <div class="callout">
              Input <code>x</code> is already scaled by 1e18. Multiply by another 1e18 before sqrt, so the result comes out correctly scaled.
            </div>
          </div>
        </div>
        <aside class="notes">The UD60x18 sqrt wrapper has a subtle scaling step. The input x is a UD60x18 value, meaning it's already multiplied by 1e18. If we just took the integer sqrt, we'd get sqrt(x * 1e18). The sqrt of the scale factor would be sqrt(1e18) = 1e9, so our result would only have 9 decimal digits instead of 18. To fix this, we multiply by 1e18 before taking the sqrt: sqrt(x * 1e18 * 1e18) = sqrt(x * 1e36) = sqrt(x) * 1e18, which is the correct UD60x18 representation.</aside>
      </section>

      <!-- ══════════════════════════════════════════════
           PART 13 — pow() AND GAS
           ══════════════════════════════════════════════ -->
      <section>
        <h2 style="color:#e74c3c;">Part 13: <code>pow()</code> &amp; Gas Costs</h2>
        <p>Putting it all together.</p>
      </section>

      <section>
        <h2>pow() — Just exp(y × ln(x))</h2>
        <pre><code class="hljs">/// @notice Raises x to the power of y.
function pow(UD60x18 x, UD60x18 y)
    pure returns (UD60x18 result)
{
    uint256 xUint = unwrap(x);
    uint256 yUint = unwrap(y);

    if (xUint == 0) return y == ZERO ? UNIT : ZERO;
    if (yUint == uUNIT) return x;

    // x^y = exp(y * ln(x))
    // = exp2(y * log2(x))    ← base-2 version
    result = exp2(mul(y, log2(x)));
}</code></pre>
        <div class="callout-green">
          <code>pow()</code> is the most expensive function because it calls <strong>both</strong> log2 and exp2. But it's still just ~3000 gas — 15% of a single SSTORE.
        </div>
        <aside class="notes">pow is elegantly simple at the top level: x^y = 2^(y * log2(x)). This identity converts arbitrary exponentiation into a log followed by an exp, both in base 2. The edge cases are handled first: 0^0 = 1 by convention, 0^y = 0, x^1 = x. For everything else, we compute log2(x), multiply by y, and call exp2. The gas cost is roughly log2 (~1200 gas) + mul (~100 gas) + exp2 (~1500 gas) = ~2800 gas total.</aside>
      </section>

      <section>
        <h2>Gas Cost Summary</h2>
        <table class="truth-table">
          <tr><th>Function</th><th>Algorithm</th><th>Gas (approx)</th><th>vs. Naive</th></tr>
          <tr><td><code>mul()</code></td><td>mulDiv18</td><td><span class="gas-tag">~100</span></td><td>safe from phantom overflow</td></tr>
          <tr><td><code>div()</code></td><td>mulDiv (scale first)</td><td><span class="gas-tag">~150</span></td><td>18-digit precision preserved</td></tr>
          <tr><td><code>sqrt()</code></td><td>Newton × 7 iterations</td><td><span class="gas-tag">~400</span></td><td>impossible naively</td></tr>
          <tr><td><code>exp()</code></td><td>exp2 + bit decomp</td><td><span class="gas-tag">~1600</span></td><td>Taylor: ~3000+</td></tr>
          <tr><td><code>ln()</code></td><td>log2 + repeated squaring</td><td><span class="gas-tag">~1200</span></td><td>Taylor: ~4000+</td></tr>
          <tr><td><code>pow()</code></td><td>exp2(y × log2(x))</td><td><span class="gas-tag">~2800</span></td><td>loop: O(n) gas</td></tr>
        </table>
        <div class="callout">
          For reference: <code>SSTORE</code> = 20,000 gas, <code>SLOAD</code> = 2,100 gas, <code>LOG</code> = 375+ gas.<br>
          All PRBMath operations are <strong>cheaper than a single storage read</strong>.
        </div>
        <aside class="notes">These gas costs assume the full computation path, not the fast path shortcuts. In practice, costs are often lower because many fast-path optimizations kick in for common values. The key takeaway: even the most expensive PRBMath function (pow at ~2800 gas) is cheaper than reading from storage (2100 gas for a warm slot, 2600 for cold). The library is extremely well-optimized for the EVM's gas model.</aside>
      </section>

      <!-- ══════════════════════════════════════════════
           SUMMARY AND TECHNIQUES
           ══════════════════════════════════════════════ -->
      <section>
        <h2>Techniques You've Learned</h2>
        <div class="two-col">
          <div>
            <table class="truth-table">
              <tr><th>Technique</th><th>Used In</th></tr>
              <tr><td>512-bit via MULMOD</td><td>mulDiv</td></tr>
              <tr><td>Modular inverse</td><td>mulDiv</td></tr>
              <tr><td>Newton-Raphson</td><td>mulDiv, sqrt</td></tr>
              <tr><td>d &amp; (-d) bit trick</td><td>mulDiv</td></tr>
            </table>
          </div>
          <div>
            <table class="truth-table">
              <tr><th>Technique</th><th>Used In</th></tr>
              <tr><td>Binary search (MSB)</td><td>log2, sqrt</td></tr>
              <tr><td>Repeated squaring</td><td>log2</td></tr>
              <tr><td>Precomputed constants</td><td>exp2</td></tr>
              <tr><td>Change of base</td><td>exp, ln, pow</td></tr>
            </table>
          </div>
        </div>
        <div class="callout">
          These 8 techniques appear throughout DeFi math — Uniswap v3's <code>TickMath</code>, Balancer's <code>LogExpMath</code>, Solmate's <code>FixedPointMathLib</code>. Learn them once, read any library.
        </div>
      </section>

      <section>
        <h2>How Everything Connects</h2>
        <pre><code class="hljs" style="font-size:0.65em; line-height:1.5;">
  pow(x, y) ──→ exp2( y × log2(x) )
                  │         │
                  ▼         ▼
  exp(x) ───→ exp2()    log2() ◄──── ln(x)
                │           │
          [bit decomp]  [repeated squaring]
                │           │
                ▼           ▼
            mulDiv()    mulDiv()
              │
        [512-bit product]
        [modular inverse]
        [Newton-Raphson]

  mul(x,y) ──→ mulDiv18(x, y)  ──→ mulDiv(x, y, 1e18)
  div(x,y) ──→ mulDiv(x, 1e18, y)
  sqrt(x)  ──→ Newton-Raphson + mulDiv for scale
        </code></pre>
        <p class="subtle"><code>mulDiv()</code> is the foundation. Every function ultimately relies on it.</p>
      </section>

      <!-- ══════════════════════════════════════════════
           EXERCISES
           ══════════════════════════════════════════════ -->
      <section>
        <h2>Code Reading Exercises</h2>
        <div class="two-col">
          <div>
            <h3>Beginner</h3>
            <ol style="font-size:0.72em;">
              <li>Open <code>Common.sol</code> — find the <code>mulDiv</code> function. Count the Yul assembly blocks.</li>
              <li>Find the 6 Newton-Raphson lines in <code>mulDiv</code>. What's the seed value?</li>
              <li>In <code>Math.sol</code>, trace <code>mul()</code> → how many function calls deep does it go?</li>
            </ol>
          </div>
          <div>
            <h3>Advanced</h3>
            <ol style="font-size:0.72em;">
              <li>In <code>exp2()</code>, find the constant for 2<sup>1/2</sup>. Verify it: compute <code>√2 × 2⁶⁴</code>.</li>
              <li>Why does <code>log2()</code> use 192.64 format instead of 60x18?</li>
              <li>What happens if you call <code>exp(ud(134e18))</code>? Where does it revert and why?</li>
            </ol>
          </div>
        </div>
        <div class="callout">
          <strong>Repo:</strong> <code>npm install @prb/math</code> then open <code>node_modules/@prb/math/src/</code>
        </div>
      </section>

      <section>
        <h2>Further Reading</h2>
        <ul>
          <li><a href="https://github.com/PaulRBerg/prb-math" style="color:#2d9cdb;">PRBMath source code (v4)</a></li>
          <li><a href="https://xn--2-umb.com/21/muldiv/" style="color:#2d9cdb;">Remco Bloemen — "Full Mul-Div"</a> — the mulDiv algorithm origin</li>
          <li><a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Heron's_method" style="color:#2d9cdb;">Babylonian / Newton's method for square roots</a></li>
          <li>Henry S. Warren, <em>Hacker's Delight</em> — the bible of bit manipulation</li>
          <li><a href="https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/TickMath.sol" style="color:#2d9cdb;">Uniswap v3 TickMath</a> — uses the same exp/log techniques</li>
        </ul>
        <div class="callout-blue">
          PRBMath is one of the best-documented Solidity libraries. The source code comments explain every step — read them!
        </div>
      </section>



      <!-- ══════════════════════════════════════════════
           WRAP-UP — PUTTING IT ALL TOGETHER
           ══════════════════════════════════════════════ -->
      <section>
        <h2 style="color:#f5a623;">Putting It All Together</h2>
        <div class="two-col">
          <div>
            <h3>What You Now Know</h3>
            <ul>
              <li>&check; Functions: input &rarr; output</li>
              <li>&check; Graphs: x-axis = supply, y-axis = price</li>
              <li>&check; Five curve shapes and their personalities</li>
              <li>&check; Area under curve = total cost</li>
              <li>&check; Fixed-point: multiply by 1e18</li>
              <li>&check; PRBMath: wrap &rarr; math &rarr; unwrap</li>
              <li>&check; mulDiv: 512-bit safe arithmetic</li>
              <li>&check; How exp, ln, sqrt, pow work internally</li>
            </ul>
          </div>
          <div>
            <h3>What's Next</h3>
            <ul>
              <li>Full buy/sell contracts with reserves</li>
              <li>Closed-form integrals for O(1) gas</li>
              <li>Sigmoid curves with sign handling</li>
              <li>Production safety: reentrancy, fees, caps</li>
              <li>Power curves, Bancor, Friend.tech</li>
            </ul>
            <div class="callout">
              You have all the math and internals knowledge you need. The bonding curves workshop is just plugging these pieces together.
            </div>
          </div>
        </div>
        <aside class="notes">Let's recap everything. You understand that a bonding curve is just a Solidity function where supply goes in and price comes out. You can read a graph and know which shape means what economically. You know total cost is the area under the curve. You know Solidity can't do decimals, so we use fixed-point (multiply by 1e18). You know PRBMath's wrap-math-unwrap pattern. And now you know the internals: mulDiv's 512-bit trick, how exp uses bit decomposition, how ln uses repeated squaring, and how sqrt uses Newton's method. The bonding curves workshop will build complete contracts using all of this.</aside>
      </section>

      <!-- ============ EXERCISE ============ -->
      <section>
        <h2>Exercise: Can You Read This?</h2>
        <pre><code class="hljs">import {UD60x18, ud, unwrap, mul, div, exp} from "prb-math/UD60x18.sol";

contract MysteryPrice {
    function getPrice(uint256 supply) external pure returns (uint256) {
        UD60x18 s = ud(supply * 1e18);
        UD60x18 k = ud(0.05e18);
        UD60x18 a = ud(2e18);
        UD60x18 b = ud(1e18);

        UD60x18 expPart = exp(mul(k, s));
        UD60x18 result  = mul(a, expPart) + b;

        return unwrap(result);
    }
}</code></pre>
        <p><strong>Questions:</strong></p>
        <ul>
          <li>What formula does this implement? <em>(Hint: 2&middot;e<sup>0.05s</sup> + ???)</em></li>
          <li>What is the price at supply = 0?</li>
          <li>Is the price at supply = 100 higher or lower than 1000 ETH?</li>
        </ul>
        <aside class="notes">Give students 2 minutes. Answers: 1) It's P = 2·e^(0.05·s) + 1. The +1 is a floor price. 2) At s=0: 2·e^0 + 1 = 2·1 + 1 = 3.0 ETH. 3) At s=100: 2·e^5 + 1 ≈ 2·148.4 + 1 ≈ 297.8 ETH. Lower than 1000. But at s=200: 2·e^10 + 1 ≈ 44,053 ETH — way over 1000.</aside>
      </section>

      <!-- ============ INTERACTIVE PLAYGROUND ============ -->
      <section>
        <h2>Playground: Build Your Own Curve</h2>
        <p>Drag the sliders to design a curve. What economic personality does it create?</p>
        <div id="calc-playground" class="calc" style="height: 260px;"></div>
        <ul>
          <li>Set <strong>n = 0.5</strong> for &radic;x &nbsp;|&nbsp; <strong>n = 1</strong> for linear &nbsp;|&nbsp; <strong>n = 2</strong> for quadratic</li>
          <li><strong>a</strong> scales the price &nbsp;|&nbsp; <strong>b</strong> sets a floor price</li>
        </ul>
        <p class="subtle">Formula: P = a &middot; x<sup>n</sup> + b. This single family covers most DeFi curves.</p>
        <aside class="notes">This is your sandbox. The formula P = a·x^n + b is surprisingly powerful. With n=0.5 you get square root. n=1 is linear. n=2 is quadratic. n=3 is cubic. The a slider scales everything, and b sets a minimum price. Play with it and get an intuition for how each parameter affects the shape. This is the same family of curves that Bancor, pump.fun, and Friend.tech all use — just with different values of a, n, and b.</aside>
      </section>

      <!-- ============ RESOURCES ============ -->
      <section>
        <h2>Resources</h2>
        <ul>
          <li>PRBMath GitHub: <a href="https://github.com/PaulRBerger/prb-math">github.com/PaulRBerger/prb-math</a></li>
          <li>PRBMath UD60x18 API: <a href="https://github.com/PaulRBerger/prb-math/blob/main/src/ud60x18/Math.sol">Math.sol source</a></li>
          <li>Fixed-Point Tutorial: <a href="https://docs.soliditylang.org/en/latest/">Solidity docs</a></li>
          <li>Desmos Graph Calculator: <a href="https://www.desmos.com/calculator">desmos.com/calculator</a> &mdash; practice graphing!</li>
          <li><strong>Next:</strong> <a href="../007_bonding_curves/">Workshop 007 &mdash; Bonding Curves</a></li>
        </ul>
        <aside class="notes">PRBMath docs are excellent — start with the README. For practice, open Desmos and type in different formulas. Try y = 0.01x^2 and see if it matches what you expect. Then try y = 2*ln(x+1). Building visual intuition will make the Solidity code much easier to follow. When you're comfortable, move to workshop 007 where we'll build full bonding curve contracts with buy, sell, and reserves.</aside>
      </section>

      <!-- ============ Q&A ============ -->
      <section>
        <h2>Q&amp;A</h2>
        <p>Quick check &mdash; can you answer these?</p>
        <ul>
          <li>Why can't Solidity do <code>0.5 * 3</code> natively?</li>
          <li>What does <code>ud(5e18)</code> represent?</li>
          <li>Why do we add <code>+ c</code> before calling <code>ln()</code>?</li>
          <li>What's the difference between a linear and exponential curve?</li>
        </ul>
        <div class="callout">
          If you can answer all four &rarr; you're ready for <strong>Workshop 007: Bonding Curves</strong>!
        </div>
        <aside class="notes">Quick pulse check. 1) Because Solidity only has integers — 0.5 doesn't exist, you need 5e17. 2) ud(5e18) represents the number 5.0 in fixed-point. 3) Because ln(0) is negative infinity and would revert. 4) Linear grows by a constant amount per step; exponential multiplies by a constant ratio per step — so it gets much steeper much faster.</aside>
      </section>

    </div>
  </div>

  <script src="https://unpkg.com/reveal.js@5.1.0/dist/reveal.js"></script>
  <script src="https://unpkg.com/reveal.js@5.1.0/plugin/notes/notes.js"></script>
  <script>
    Reveal.initialize({ hash: true, slideNumber: true, transition: 'slide', plugins: [ RevealNotes ] });

    window.addEventListener('load', () => {
      const opts = { expressions: true, settingsMenu: false, zoomButtons: false, expressionsTopbar: false };

      /* ---- INTRO LINE ---- */
      const introLine = Desmos.GraphingCalculator(document.getElementById('calc-intro-line'), opts);
      introLine.setExpression({ id: 'm', latex: 'm=0.5', sliderBounds: { min: 0, max: 2, step: 0.05 } });
      introLine.setExpression({ id: 'b', latex: 'b=1',   sliderBounds: { min: 0, max: 5, step: 0.1 } });
      introLine.setExpression({ id: 'f', latex: 'f(x)=m\\cdot x+b', color: '#2d9cdb' });
      introLine.setMathBounds({ left: -1, right: 20, bottom: -1, top: 15 });

      /* ---- SLOPE ---- */
      const slope = Desmos.GraphingCalculator(document.getElementById('calc-slope'), opts);
      slope.setExpression({ id: 'm', latex: 'm=1', sliderBounds: { min: 0, max: 3, step: 0.1 } });
      slope.setExpression({ id: 'f', latex: 'y=m\\cdot x', color: '#2d9cdb' });
      slope.setExpression({ id: 'rise', latex: '(5, 5m)', color: '#f5a623', pointStyle: 'POINT', showLabel: true, label: 'slope = m' });
      slope.setMathBounds({ left: -1, right: 15, bottom: -1, top: 20 });

      /* ---- LINE VS CURVE ---- */
      const lvc = Desmos.GraphingCalculator(document.getElementById('calc-line-vs-curve'), opts);
      lvc.setExpression({ id: 'lin', latex: 'y=0.5x+1', color: '#2d9cdb' });
      lvc.setExpression({ id: 'exp', latex: 'y=e^{0.1x}', color: '#e97b2e' });
      lvc.setExpression({ id: 'log', latex: 'y=3\\cdot\\ln(x+1)', color: '#27ae60' });
      lvc.setMathBounds({ left: -1, right: 30, bottom: -1, top: 20 });

      /* ---- QUADRATIC ---- */
      const quad = Desmos.GraphingCalculator(document.getElementById('calc-quadratic'), opts);
      quad.setExpression({ id: 'a', latex: 'a=0.01', sliderBounds: { min: 0.001, max: 0.1, step: 0.001 } });
      quad.setExpression({ id: 'f', latex: 'y=a\\cdot x^{2}', color: '#e74c3c' });
      quad.setMathBounds({ left: -1, right: 50, bottom: -1, top: 25 });

      /* ---- SQUARE ROOT ---- */
      const sqrtCalc = Desmos.GraphingCalculator(document.getElementById('calc-sqrt'), opts);
      sqrtCalc.setExpression({ id: 'a', latex: 'a=1', sliderBounds: { min: 0.1, max: 5, step: 0.1 } });
      sqrtCalc.setExpression({ id: 'f', latex: 'y=a\\cdot\\sqrt{x}', color: '#27ae60' });
      sqrtCalc.setMathBounds({ left: -1, right: 100, bottom: -1, top: 12 });

      /* ---- EXPONENTIAL ---- */
      const expoCalc = Desmos.GraphingCalculator(document.getElementById('calc-expo'), opts);
      expoCalc.setExpression({ id: 'k', latex: 'k=0.3', sliderBounds: { min: 0.05, max: 0.5, step: 0.01 } });
      expoCalc.setExpression({ id: 'f', latex: 'y=e^{k\\cdot x}', color: '#e97b2e' });
      expoCalc.setMathBounds({ left: -1, right: 15, bottom: -1, top: 30 });

      /* ---- LOG ---- */
      const logCalc = Desmos.GraphingCalculator(document.getElementById('calc-log-intro'), opts);
      logCalc.setExpression({ id: 'k', latex: 'k=2', sliderBounds: { min: 0.5, max: 5, step: 0.1 } });
      logCalc.setExpression({ id: 'f', latex: 'y=k\\cdot\\ln(x+1)', color: '#9b59b6' });
      logCalc.setMathBounds({ left: -1, right: 100, bottom: -2, top: 12 });

      /* ---- ALL FIVE ---- */
      const all = Desmos.GraphingCalculator(document.getElementById('calc-all-five'), opts);
      all.setExpression({ id: 'lin',  latex: 'y=0.2x+1',         color: '#2d9cdb' });
      all.setExpression({ id: 'quad', latex: 'y=0.02x^{2}',      color: '#e74c3c' });
      all.setExpression({ id: 'sqrt', latex: 'y=2\\sqrt{x}',     color: '#27ae60' });
      all.setExpression({ id: 'exp',  latex: 'y=e^{0.08x}',      color: '#e97b2e' });
      all.setExpression({ id: 'log',  latex: 'y=2\\ln(x+1)',     color: '#9b59b6' });
      all.setMathBounds({ left: -1, right: 50, bottom: -1, top: 30 });

      /* ---- AREA UNDER CURVE ---- */
      const area = Desmos.GraphingCalculator(document.getElementById('calc-area'), opts);
      area.setExpression({ id: 'f', latex: 'f(x)=0.5x+1', color: '#2d9cdb' });
      area.setExpression({ id: 'fill', latex: '1\\le y\\le f(x)\\left\\{2\\le x\\le 8\\right\\}', color: '#2d9cdb' });
      area.setExpression({ id: 'a_pt', latex: '(2, f(2))', color: '#f5a623', pointStyle: 'POINT', showLabel: true, label: 'start: s=2' });
      area.setExpression({ id: 'b_pt', latex: '(8, f(8))', color: '#f5a623', pointStyle: 'POINT', showLabel: true, label: 'end: s=8' });
      area.setMathBounds({ left: -1, right: 12, bottom: -0.5, top: 7 });

      /* ---- PLAYGROUND ---- */
      const play = Desmos.GraphingCalculator(document.getElementById('calc-playground'), opts);
      play.setExpression({ id: 'a', latex: 'a=0.1',  sliderBounds: { min: 0.001, max: 2, step: 0.001 } });
      play.setExpression({ id: 'n', latex: 'n=1',     sliderBounds: { min: 0.1, max: 3, step: 0.1 } });
      play.setExpression({ id: 'b', latex: 'b=0',     sliderBounds: { min: 0, max: 5, step: 0.1 } });
      play.setExpression({ id: 'f', latex: 'P=a\\cdot x^{n}+b', color: '#f5a623' });
      play.setMathBounds({ left: -1, right: 50, bottom: -1, top: 30 });
    });
  </script>
</body>
</html>
